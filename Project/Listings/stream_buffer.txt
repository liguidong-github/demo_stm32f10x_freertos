; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\stream_buffer.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\stream_buffer.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\User -I..\STM32F10x_StdPeriph_Libraries -I..\STM32F10x_StdPeriph_Libraries\STM32F10x_StdPeriph_Driver\src -I..\STM32F10x_StdPeriph_Libraries\STM32F10x_StdPeriph_Driver\inc -I..\STM32F10x_StdPeriph_Libraries\CMSIS\CM3\CoreSupport -I..\STM32F10x_StdPeriph_Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\STM32F10x_StdPeriph_Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\startup\arm -I..\FreeRTOS\Source -I..\FreeRTOS\Source\include -I..\FreeRTOS\Source\portable\RVDS\ARM_CM3 -I..\FreeRTOS\Source\portable\MemMang -I..\FreeRTOS -I..\User\Bsp -I..\SEGGER_RTT\RTT -I.\RTE\_Demo -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.0.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=523 -DSTM32F10X_MD -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER --omf_browse=.\objects\stream_buffer.crf ..\FreeRTOS\Source\stream_buffer.c]
                          THUMB

                          AREA ||i.prvBytesInBuffer||, CODE, READONLY, ALIGN=1

                  prvBytesInBuffer PROC
;;;1188   
;;;1189   static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
000000  4601              MOV      r1,r0
;;;1190   {
;;;1191   /* Returns the distance between xTail and xHead. */
;;;1192   size_t xCount;
;;;1193   
;;;1194   	xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
000002  e9d13201          LDRD     r3,r2,[r1,#4]
000006  18d0              ADDS     r0,r2,r3
;;;1195   	xCount -= pxStreamBuffer->xTail;
000008  680a              LDR      r2,[r1,#0]
00000a  1a80              SUBS     r0,r0,r2
;;;1196   	if ( xCount >= pxStreamBuffer->xLength )
00000c  688a              LDR      r2,[r1,#8]
00000e  4282              CMP      r2,r0
000010  d801              BHI      |L1.22|
;;;1197   	{
;;;1198   		xCount -= pxStreamBuffer->xLength;
000012  688a              LDR      r2,[r1,#8]
000014  1a80              SUBS     r0,r0,r2
                  |L1.22|
;;;1199   	}
;;;1200   	else
;;;1201   	{
;;;1202   		mtCOVERAGE_TEST_MARKER();
;;;1203   	}
;;;1204   
;;;1205   	return xCount;
;;;1206   }
000016  4770              BX       lr
;;;1207   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvInitialiseNewStreamBuffer||, CODE, READONLY, ALIGN=1

                  prvInitialiseNewStreamBuffer PROC
;;;1208   
;;;1209   static void prvInitialiseNewStreamBuffer( StreamBuffer_t * const pxStreamBuffer,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1210   										  uint8_t * const pucBuffer,
;;;1211   										  size_t xBufferSizeBytes,
;;;1212   										  size_t xTriggerLevelBytes,
;;;1213   										  uint8_t ucFlags )
;;;1214   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
00000a  461e              MOV      r6,r3
00000c  f8dd8018          LDR      r8,[sp,#0x18]
;;;1215   	/* Assert here is deliberately writing to the entire buffer to ensure it can
;;;1216   	be written to without generating exceptions, and is setting the buffer to a
;;;1217   	known value to assist in development/debugging. */
;;;1218   	#if( configASSERT_DEFINED == 1 )
;;;1219   	{
;;;1220   		/* The value written just has to be identifiable when looking at the
;;;1221   		memory.  Don't use 0xA5 as that is the stack fill value and could
;;;1222   		result in confusion as to what is actually being observed. */
;;;1223   		const BaseType_t xWriteValue = 0x55;
;;;1224   		configASSERT( memset( pucBuffer, ( int ) xWriteValue, xBufferSizeBytes ) == pucBuffer );
;;;1225   	} /*lint !e529 !e438 xWriteValue is only used if configASSERT() is defined. */
;;;1226   	#endif
;;;1227   
;;;1228   	( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) ); /*lint !e9087 memset() requires void *. */
000010  2120              MOVS     r1,#0x20
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       __aeabi_memclr4
;;;1229   	pxStreamBuffer->pucBuffer = pucBuffer;
000018  61a5              STR      r5,[r4,#0x18]
;;;1230   	pxStreamBuffer->xLength = xBufferSizeBytes;
00001a  60a7              STR      r7,[r4,#8]
;;;1231   	pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
00001c  60e6              STR      r6,[r4,#0xc]
;;;1232   	pxStreamBuffer->ucFlags = ucFlags;
00001e  f884801c          STRB     r8,[r4,#0x1c]
;;;1233   }
000022  e8bd81f0          POP      {r4-r8,pc}
;;;1234   
                          ENDP


                          AREA ||i.prvReadBytesFromBuffer||, CODE, READONLY, ALIGN=1

                  prvReadBytesFromBuffer PROC
;;;1133   
;;;1134   static size_t prvReadBytesFromBuffer( StreamBuffer_t *pxStreamBuffer, uint8_t *pucData, size_t xMaxCount, size_t xBytesAvailable )
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1135   {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
000008  4691              MOV      r9,r2
00000a  469a              MOV      r10,r3
;;;1136   size_t xCount, xFirstLength, xNextTail;
;;;1137   
;;;1138   	/* Use the minimum of the wanted bytes and the available bytes. */
;;;1139   	xCount = configMIN( xBytesAvailable, xMaxCount );
00000c  45ca              CMP      r10,r9
00000e  d201              BCS      |L3.20|
000010  4650              MOV      r0,r10
000012  e000              B        |L3.22|
                  |L3.20|
000014  4648              MOV      r0,r9
                  |L3.22|
000016  4606              MOV      r6,r0
;;;1140   
;;;1141   	if( xCount > ( size_t ) 0 )
000018  b1f6              CBZ      r6,|L3.88|
;;;1142   	{
;;;1143   		xNextTail = pxStreamBuffer->xTail;
00001a  6825              LDR      r5,[r4,#0]
;;;1144   
;;;1145   		/* Calculate the number of bytes that can be read - which may be
;;;1146   		less than the number wanted if the data wraps around to the start of
;;;1147   		the buffer. */
;;;1148   		xFirstLength = configMIN( pxStreamBuffer->xLength - xNextTail, xCount );
00001c  68a0              LDR      r0,[r4,#8]
00001e  1b40              SUBS     r0,r0,r5
000020  42b0              CMP      r0,r6
000022  d202              BCS      |L3.42|
000024  68a0              LDR      r0,[r4,#8]
000026  1b40              SUBS     r0,r0,r5
000028  e000              B        |L3.44|
                  |L3.42|
00002a  4630              MOV      r0,r6
                  |L3.44|
00002c  4607              MOV      r7,r0
;;;1149   
;;;1150   		/* Obtain the number of bytes it is possible to obtain in the first
;;;1151   		read.  Asserts check bounds of read and write. */
;;;1152   		configASSERT( xFirstLength <= xMaxCount );
;;;1153   		configASSERT( ( xNextTail + xFirstLength ) <= pxStreamBuffer->xLength );
;;;1154   		( void ) memcpy( ( void * ) pucData, ( const void * ) &( pxStreamBuffer->pucBuffer[ xNextTail ] ), xFirstLength ); /*lint !e9087 memcpy() requires void *. */
00002e  69a0              LDR      r0,[r4,#0x18]
000030  1941              ADDS     r1,r0,r5
000032  463a              MOV      r2,r7
000034  4640              MOV      r0,r8
000036  f7fffffe          BL       __aeabi_memcpy
;;;1155   
;;;1156   		/* If the total number of wanted bytes is greater than the number
;;;1157   		that could be read in the first read... */
;;;1158   		if( xCount > xFirstLength )
00003a  42be              CMP      r6,r7
00003c  d905              BLS      |L3.74|
;;;1159   		{
;;;1160   			/*...then read the remaining bytes from the start of the buffer. */
;;;1161   			configASSERT( xCount <= xMaxCount );
;;;1162   			( void ) memcpy( ( void * ) &( pucData[ xFirstLength ] ), ( void * ) ( pxStreamBuffer->pucBuffer ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
00003e  1bf2              SUBS     r2,r6,r7
000040  eb080007          ADD      r0,r8,r7
000044  69a1              LDR      r1,[r4,#0x18]
000046  f7fffffe          BL       __aeabi_memcpy
                  |L3.74|
;;;1163   		}
;;;1164   		else
;;;1165   		{
;;;1166   			mtCOVERAGE_TEST_MARKER();
;;;1167   		}
;;;1168   
;;;1169   		/* Move the tail pointer to effectively remove the data read from
;;;1170   		the buffer. */
;;;1171   		xNextTail += xCount;
00004a  4435              ADD      r5,r5,r6
;;;1172   
;;;1173   		if( xNextTail >= pxStreamBuffer->xLength )
00004c  68a0              LDR      r0,[r4,#8]
00004e  42a8              CMP      r0,r5
000050  d801              BHI      |L3.86|
;;;1174   		{
;;;1175   			xNextTail -= pxStreamBuffer->xLength;
000052  68a0              LDR      r0,[r4,#8]
000054  1a2d              SUBS     r5,r5,r0
                  |L3.86|
;;;1176   		}
;;;1177   
;;;1178   		pxStreamBuffer->xTail = xNextTail;
000056  6025              STR      r5,[r4,#0]
                  |L3.88|
;;;1179   	}
;;;1180   	else
;;;1181   	{
;;;1182   		mtCOVERAGE_TEST_MARKER();
;;;1183   	}
;;;1184   
;;;1185   	return xCount;
000058  4630              MOV      r0,r6
;;;1186   }
00005a  e8bd87f0          POP      {r4-r10,pc}
;;;1187   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvReadMessageFromBuffer||, CODE, READONLY, ALIGN=1

                  prvReadMessageFromBuffer PROC
;;;917    
;;;918    static size_t prvReadMessageFromBuffer( StreamBuffer_t *pxStreamBuffer,
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;919    										void *pvRxData,
;;;920    										size_t xBufferLengthBytes,
;;;921    										size_t xBytesAvailable,
;;;922    										size_t xBytesToStoreMessageLength )
;;;923    {
000004  4605              MOV      r5,r0
000006  468a              MOV      r10,r1
000008  4616              MOV      r6,r2
00000a  4698              MOV      r8,r3
00000c  9f0a              LDR      r7,[sp,#0x28]
;;;924    size_t xOriginalTail, xReceivedLength, xNextMessageLength;
;;;925    configMESSAGE_BUFFER_LENGTH_TYPE xTempNextMessageLength;
;;;926    
;;;927    	if( xBytesToStoreMessageLength != ( size_t ) 0 )
00000e  b187              CBZ      r7,|L4.50|
;;;928    	{
;;;929    		/* A discrete message is being received.  First receive the length
;;;930    		of the message.  A copy of the tail is stored so the buffer can be
;;;931    		returned to its prior state if the length of the message is too
;;;932    		large for the provided buffer. */
;;;933    		xOriginalTail = pxStreamBuffer->xTail;
000010  f8d59000          LDR      r9,[r5,#0]
;;;934    		( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempNextMessageLength, xBytesToStoreMessageLength, xBytesAvailable );
000014  4643              MOV      r3,r8
000016  463a              MOV      r2,r7
000018  4669              MOV      r1,sp
00001a  4628              MOV      r0,r5
00001c  f7fffffe          BL       prvReadBytesFromBuffer
;;;935    		xNextMessageLength = ( size_t ) xTempNextMessageLength;
000020  9c00              LDR      r4,[sp,#0]
;;;936    
;;;937    		/* Reduce the number of bytes available by the number of bytes just
;;;938    		read out. */
;;;939    		xBytesAvailable -= xBytesToStoreMessageLength;
000022  eba80807          SUB      r8,r8,r7
;;;940    
;;;941    		/* Check there is enough space in the buffer provided by the
;;;942    		user. */
;;;943    		if( xNextMessageLength > xBufferLengthBytes )
000026  42b4              CMP      r4,r6
000028  d904              BLS      |L4.52|
;;;944    		{
;;;945    			/* The user has provided insufficient space to read the message
;;;946    			so return the buffer to its previous state (so the length of
;;;947    			the message is in the buffer again). */
;;;948    			pxStreamBuffer->xTail = xOriginalTail;
00002a  f8c59000          STR      r9,[r5,#0]
;;;949    			xNextMessageLength = 0;
00002e  2400              MOVS     r4,#0
000030  e000              B        |L4.52|
                  |L4.50|
;;;950    		}
;;;951    		else
;;;952    		{
;;;953    			mtCOVERAGE_TEST_MARKER();
;;;954    		}
;;;955    	}
;;;956    	else
;;;957    	{
;;;958    		/* A stream of bytes is being received (as opposed to a discrete
;;;959    		message), so read as many bytes as possible. */
;;;960    		xNextMessageLength = xBufferLengthBytes;
000032  4634              MOV      r4,r6
                  |L4.52|
;;;961    	}
;;;962    
;;;963    	/* Read the actual data. */
;;;964    	xReceivedLength = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) pvRxData, xNextMessageLength, xBytesAvailable ); /*lint !e9079 Data storage area is implemented as uint8_t array for ease of sizing, indexing and alignment. */
000034  4643              MOV      r3,r8
000036  4622              MOV      r2,r4
000038  4651              MOV      r1,r10
00003a  4628              MOV      r0,r5
00003c  f7fffffe          BL       prvReadBytesFromBuffer
000040  4683              MOV      r11,r0
;;;965    
;;;966    	return xReceivedLength;
000042  4658              MOV      r0,r11
;;;967    }
000044  e8bd8ff8          POP      {r3-r11,pc}
;;;968    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvWriteBytesToBuffer||, CODE, READONLY, ALIGN=1

                  prvWriteBytesToBuffer PROC
;;;1087   
;;;1088   static size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer, const uint8_t *pucData, size_t xCount )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1089   {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
000008  4616              MOV      r6,r2
;;;1090   size_t xNextHead, xFirstLength;
;;;1091   
;;;1092   	configASSERT( xCount > ( size_t ) 0 );
;;;1093   
;;;1094   	xNextHead = pxStreamBuffer->xHead;
00000a  6865              LDR      r5,[r4,#4]
;;;1095   
;;;1096   	/* Calculate the number of bytes that can be added in the first write -
;;;1097   	which may be less than the total number of bytes that need to be added if
;;;1098   	the buffer will wrap back to the beginning. */
;;;1099   	xFirstLength = configMIN( pxStreamBuffer->xLength - xNextHead, xCount );
00000c  68a0              LDR      r0,[r4,#8]
00000e  1b40              SUBS     r0,r0,r5
000010  42b0              CMP      r0,r6
000012  d202              BCS      |L5.26|
000014  68a0              LDR      r0,[r4,#8]
000016  1b40              SUBS     r0,r0,r5
000018  e000              B        |L5.28|
                  |L5.26|
00001a  4630              MOV      r0,r6
                  |L5.28|
00001c  4607              MOV      r7,r0
;;;1100   
;;;1101   	/* Write as many bytes as can be written in the first write. */
;;;1102   	configASSERT( ( xNextHead + xFirstLength ) <= pxStreamBuffer->xLength );
;;;1103   	( void ) memcpy( ( void* ) ( &( pxStreamBuffer->pucBuffer[ xNextHead ] ) ), ( const void * ) pucData, xFirstLength ); /*lint !e9087 memcpy() requires void *. */
00001e  69a1              LDR      r1,[r4,#0x18]
000020  1948              ADDS     r0,r1,r5
000022  463a              MOV      r2,r7
000024  4641              MOV      r1,r8
000026  f7fffffe          BL       __aeabi_memcpy
;;;1104   
;;;1105   	/* If the number of bytes written was less than the number that could be
;;;1106   	written in the first write... */
;;;1107   	if( xCount > xFirstLength )
00002a  42be              CMP      r6,r7
00002c  d905              BLS      |L5.58|
;;;1108   	{
;;;1109   		/* ...then write the remaining bytes to the start of the buffer. */
;;;1110   		configASSERT( ( xCount - xFirstLength ) <= pxStreamBuffer->xLength );
;;;1111   		( void ) memcpy( ( void * ) pxStreamBuffer->pucBuffer, ( const void * ) &( pucData[ xFirstLength ] ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
00002e  1bf2              SUBS     r2,r6,r7
000030  eb080107          ADD      r1,r8,r7
000034  69a0              LDR      r0,[r4,#0x18]
000036  f7fffffe          BL       __aeabi_memcpy
                  |L5.58|
;;;1112   	}
;;;1113   	else
;;;1114   	{
;;;1115   		mtCOVERAGE_TEST_MARKER();
;;;1116   	}
;;;1117   
;;;1118   	xNextHead += xCount;
00003a  4435              ADD      r5,r5,r6
;;;1119   	if( xNextHead >= pxStreamBuffer->xLength )
00003c  68a0              LDR      r0,[r4,#8]
00003e  42a8              CMP      r0,r5
000040  d801              BHI      |L5.70|
;;;1120   	{
;;;1121   		xNextHead -= pxStreamBuffer->xLength;
000042  68a0              LDR      r0,[r4,#8]
000044  1a2d              SUBS     r5,r5,r0
                  |L5.70|
;;;1122   	}
;;;1123   	else
;;;1124   	{
;;;1125   		mtCOVERAGE_TEST_MARKER();
;;;1126   	}
;;;1127   
;;;1128   	pxStreamBuffer->xHead = xNextHead;
000046  6065              STR      r5,[r4,#4]
;;;1129   
;;;1130   	return xCount;
000048  4630              MOV      r0,r6
;;;1131   }
00004a  e8bd81f0          POP      {r4-r8,pc}
;;;1132   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvWriteMessageToBuffer||, CODE, READONLY, ALIGN=1

                  prvWriteMessageToBuffer PROC
;;;660    
;;;661    static size_t prvWriteMessageToBuffer( StreamBuffer_t * const pxStreamBuffer,
000000  e92d47ff          PUSH     {r0-r10,lr}
;;;662    									   const void * pvTxData,
;;;663    									   size_t xDataLengthBytes,
;;;664    									   size_t xSpace,
;;;665    									   size_t xRequiredSpace )
;;;666    {
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
000008  461d              MOV      r5,r3
00000a  f8dd9030          LDR      r9,[sp,#0x30]
;;;667    	BaseType_t xShouldWrite;
;;;668    	size_t xReturn;
;;;669    
;;;670    	if( xSpace == ( size_t ) 0 )
00000e  b90d              CBNZ     r5,|L6.20|
;;;671    	{
;;;672    		/* Doesn't matter if this is a stream buffer or a message buffer, there
;;;673    		is no space to write. */
;;;674    		xShouldWrite = pdFALSE;
000010  2400              MOVS     r4,#0
000012  e016              B        |L6.66|
                  |L6.20|
;;;675    	}
;;;676    	else if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) == ( uint8_t ) 0 )
000014  7f38              LDRB     r0,[r7,#0x1c]
000016  f0000001          AND      r0,r0,#1
00001a  b940              CBNZ     r0,|L6.46|
;;;677    	{
;;;678    		/* This is a stream buffer, as opposed to a message buffer, so writing a
;;;679    		stream of bytes rather than discrete messages.  Write as many bytes as
;;;680    		possible. */
;;;681    		xShouldWrite = pdTRUE;
00001c  2401              MOVS     r4,#1
;;;682    		xDataLengthBytes = configMIN( xDataLengthBytes, xSpace );
00001e  9802              LDR      r0,[sp,#8]
000020  42a8              CMP      r0,r5
000022  d201              BCS      |L6.40|
000024  9802              LDR      r0,[sp,#8]
000026  e000              B        |L6.42|
                  |L6.40|
000028  4628              MOV      r0,r5
                  |L6.42|
00002a  9002              STR      r0,[sp,#8]
00002c  e009              B        |L6.66|
                  |L6.46|
;;;683    	}
;;;684    	else if( xSpace >= xRequiredSpace )
00002e  454d              CMP      r5,r9
000030  d306              BCC      |L6.64|
;;;685    	{
;;;686    		/* This is a message buffer, as opposed to a stream buffer, and there
;;;687    		is enough space to write both the message length and the message itself
;;;688    		into the buffer.  Start by writing the length of the data, the data
;;;689    		itself will be written later in this function. */
;;;690    		xShouldWrite = pdTRUE;
000032  2401              MOVS     r4,#1
;;;691    		( void ) prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) &( xDataLengthBytes ), sbBYTES_TO_STORE_MESSAGE_LENGTH );
000034  2204              MOVS     r2,#4
000036  a902              ADD      r1,sp,#8
000038  4638              MOV      r0,r7
00003a  f7fffffe          BL       prvWriteBytesToBuffer
00003e  e000              B        |L6.66|
                  |L6.64|
;;;692    	}
;;;693    	else
;;;694    	{
;;;695    		/* There is space available, but not enough space. */
;;;696    		xShouldWrite = pdFALSE;
000040  2400              MOVS     r4,#0
                  |L6.66|
;;;697    	}
;;;698    
;;;699    	if( xShouldWrite != pdFALSE )
000042  b134              CBZ      r4,|L6.82|
;;;700    	{
;;;701    		/* Writes the data itself. */
;;;702    		xReturn = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) pvTxData, xDataLengthBytes ); /*lint !e9079 Storage buffer is implemented as uint8_t for ease of sizing, alighment and access. */
000044  4641              MOV      r1,r8
000046  4638              MOV      r0,r7
000048  9a02              LDR      r2,[sp,#8]
00004a  f7fffffe          BL       prvWriteBytesToBuffer
00004e  4606              MOV      r6,r0
000050  e000              B        |L6.84|
                  |L6.82|
;;;703    	}
;;;704    	else
;;;705    	{
;;;706    		xReturn = 0;
000052  2600              MOVS     r6,#0
                  |L6.84|
;;;707    	}
;;;708    
;;;709    	return xReturn;
000054  4630              MOV      r0,r6
;;;710    }
000056  b004              ADD      sp,sp,#0x10
000058  e8bd87f0          POP      {r4-r10,pc}
;;;711    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.vStreamBufferDelete||, CODE, READONLY, ALIGN=1

                  vStreamBufferDelete PROC
;;;358    
;;;359    void vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer )
000000  b570              PUSH     {r4-r6,lr}
;;;360    {
000002  4604              MOV      r4,r0
;;;361    StreamBuffer_t * pxStreamBuffer = xStreamBuffer;
000004  4625              MOV      r5,r4
;;;362    
;;;363    	configASSERT( pxStreamBuffer );
;;;364    
;;;365    	traceSTREAM_BUFFER_DELETE( xStreamBuffer );
;;;366    
;;;367    	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) pdFALSE )
000006  7f28              LDRB     r0,[r5,#0x1c]
000008  f0000002          AND      r0,r0,#2
00000c  b918              CBNZ     r0,|L7.22|
;;;368    	{
;;;369    		#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
;;;370    		{
;;;371    			/* Both the structure and the buffer were allocated using a single call
;;;372    			to pvPortMalloc(), hence only one call to vPortFree() is required. */
;;;373    			vPortFree( ( void * ) pxStreamBuffer ); /*lint !e9087 Standard free() semantics require void *, plus pxStreamBuffer was allocated by pvPortMalloc(). */
00000e  4628              MOV      r0,r5
000010  f7fffffe          BL       vPortFree
000014  e003              B        |L7.30|
                  |L7.22|
;;;374    		}
;;;375    		#else
;;;376    		{
;;;377    			/* Should not be possible to get here, ucFlags must be corrupt.
;;;378    			Force an assert. */
;;;379    			configASSERT( xStreamBuffer == ( StreamBufferHandle_t ) ~0 );
;;;380    		}
;;;381    		#endif
;;;382    	}
;;;383    	else
;;;384    	{
;;;385    		/* The structure and buffer were not allocated dynamically and cannot be
;;;386    		freed - just scrub the structure so future use will assert. */
;;;387    		( void ) memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
000016  2120              MOVS     r1,#0x20
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       __aeabi_memclr4
                  |L7.30|
;;;388    	}
;;;389    }
00001e  bd70              POP      {r4-r6,pc}
;;;390    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xStreamBufferBytesAvailable||, CODE, READONLY, ALIGN=1

                  xStreamBufferBytesAvailable PROC
;;;493    
;;;494    size_t xStreamBufferBytesAvailable( StreamBufferHandle_t xStreamBuffer )
000000  b570              PUSH     {r4-r6,lr}
;;;495    {
000002  4604              MOV      r4,r0
;;;496    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
000004  4625              MOV      r5,r4
;;;497    size_t xReturn;
;;;498    
;;;499    	configASSERT( pxStreamBuffer );
;;;500    
;;;501    	xReturn = prvBytesInBuffer( pxStreamBuffer );
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       prvBytesInBuffer
00000c  4606              MOV      r6,r0
;;;502    	return xReturn;
00000e  4630              MOV      r0,r6
;;;503    }
000010  bd70              POP      {r4-r6,pc}
;;;504    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xStreamBufferGenericCreate||, CODE, READONLY, ALIGN=1

                  xStreamBufferGenericCreate PROC
;;;218    
;;;219    	StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes, size_t xTriggerLevelBytes, BaseType_t xIsMessageBuffer )
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;220    	{
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4690              MOV      r8,r2
;;;221    	uint8_t *pucAllocatedMemory;
;;;222    	uint8_t ucFlags;
;;;223    
;;;224    		/* In case the stream buffer is going to be used as a message buffer
;;;225    		(that is, it will hold discrete messages with a little meta data that
;;;226    		says how big the next message is) check the buffer will be large enough
;;;227    		to hold at least one message. */
;;;228    		if( xIsMessageBuffer == pdTRUE )
00000a  f1b80f01          CMP      r8,#1
00000e  d101              BNE      |L9.20|
;;;229    		{
;;;230    			/* Is a message buffer but not statically allocated. */
;;;231    			ucFlags = sbFLAGS_IS_MESSAGE_BUFFER;
000010  2701              MOVS     r7,#1
000012  e000              B        |L9.22|
                  |L9.20|
;;;232    			configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );
;;;233    		}
;;;234    		else
;;;235    		{
;;;236    			/* Not a message buffer and not statically allocated. */
;;;237    			ucFlags = 0;
000014  2700              MOVS     r7,#0
                  |L9.22|
;;;238    			configASSERT( xBufferSizeBytes > 0 );
;;;239    		}
;;;240    		configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );
;;;241    
;;;242    		/* A trigger level of 0 would cause a waiting task to unblock even when
;;;243    		the buffer was empty. */
;;;244    		if( xTriggerLevelBytes == ( size_t ) 0 )
000016  b906              CBNZ     r6,|L9.26|
;;;245    		{
;;;246    			xTriggerLevelBytes = ( size_t ) 1;
000018  2601              MOVS     r6,#1
                  |L9.26|
;;;247    		}
;;;248    
;;;249    		/* A stream buffer requires a StreamBuffer_t structure and a buffer.
;;;250    		Both are allocated in a single call to pvPortMalloc().  The
;;;251    		StreamBuffer_t structure is placed at the start of the allocated memory
;;;252    		and the buffer follows immediately after.  The requested size is
;;;253    		incremented so the free space is returned as the user would expect -
;;;254    		this is a quirk of the implementation that means otherwise the free
;;;255    		space would be reported as one byte smaller than would be logically
;;;256    		expected. */
;;;257    		xBufferSizeBytes++;
00001a  1c64              ADDS     r4,r4,#1
;;;258    		pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); /*lint !e9079 malloc() only returns void*. */
00001c  f1040020          ADD      r0,r4,#0x20
000020  f7fffffe          BL       pvPortMalloc
000024  4605              MOV      r5,r0
;;;259    
;;;260    		if( pucAllocatedMemory != NULL )
000026  b13d              CBZ      r5,|L9.56|
;;;261    		{
;;;262    			prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory, /* Structure at the start of the allocated memory. */ /*lint !e9087 Safe cast as allocated memory is aligned. */ /*lint !e826 Area is not too small and alignment is guaranteed provided malloc() behaves as expected and returns aligned buffer. */
000028  4633              MOV      r3,r6
00002a  4622              MOV      r2,r4
00002c  f1050120          ADD      r1,r5,#0x20
000030  4628              MOV      r0,r5
000032  9700              STR      r7,[sp,#0]
000034  f7fffffe          BL       prvInitialiseNewStreamBuffer
                  |L9.56|
;;;263    										   pucAllocatedMemory + sizeof( StreamBuffer_t ),  /* Storage area follows. */ /*lint !e9016 Indexing past structure valid for uint8_t pointer, also storage area has no alignment requirement. */
;;;264    										   xBufferSizeBytes,
;;;265    										   xTriggerLevelBytes,
;;;266    										   ucFlags );
;;;267    
;;;268    			traceSTREAM_BUFFER_CREATE( ( ( StreamBuffer_t * ) pucAllocatedMemory ), xIsMessageBuffer );
;;;269    		}
;;;270    		else
;;;271    		{
;;;272    			traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer );
;;;273    		}
;;;274    
;;;275    		return ( StreamBufferHandle_t ) pucAllocatedMemory; /*lint !e9087 !e826 Safe cast as allocated memory is aligned. */
000038  4628              MOV      r0,r5
;;;276    	}
00003a  e8bd83f8          POP      {r3-r9,pc}
;;;277    
                          ENDP


                          AREA ||i.xStreamBufferIsEmpty||, CODE, READONLY, ALIGN=1

                  xStreamBufferIsEmpty PROC
;;;969    
;;;970    BaseType_t xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer )
000000  b510              PUSH     {r4,lr}
;;;971    {
000002  4601              MOV      r1,r0
;;;972    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
000004  460a              MOV      r2,r1
;;;973    BaseType_t xReturn;
;;;974    size_t xTail;
;;;975    
;;;976    	configASSERT( pxStreamBuffer );
;;;977    
;;;978    	/* True if no bytes are available. */
;;;979    	xTail = pxStreamBuffer->xTail;
000006  6813              LDR      r3,[r2,#0]
;;;980    	if( pxStreamBuffer->xHead == xTail )
000008  6854              LDR      r4,[r2,#4]
00000a  429c              CMP      r4,r3
00000c  d101              BNE      |L10.18|
;;;981    	{
;;;982    		xReturn = pdTRUE;
00000e  2001              MOVS     r0,#1
000010  e000              B        |L10.20|
                  |L10.18|
;;;983    	}
;;;984    	else
;;;985    	{
;;;986    		xReturn = pdFALSE;
000012  2000              MOVS     r0,#0
                  |L10.20|
;;;987    	}
;;;988    
;;;989    	return xReturn;
;;;990    }
000014  bd10              POP      {r4,pc}
;;;991    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xStreamBufferIsFull||, CODE, READONLY, ALIGN=1

                  xStreamBufferIsFull PROC
;;;992    
;;;993    BaseType_t xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer )
000000  b5f0              PUSH     {r4-r7,lr}
;;;994    {
000002  4604              MOV      r4,r0
;;;995    BaseType_t xReturn;
;;;996    size_t xBytesToStoreMessageLength;
;;;997    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
000004  4627              MOV      r7,r4
;;;998    
;;;999    	configASSERT( pxStreamBuffer );
;;;1000   
;;;1001   	/* This generic version of the receive function is used by both message
;;;1002   	buffers, which store discrete messages, and stream buffers, which store a
;;;1003   	continuous stream of bytes.  Discrete messages include an additional
;;;1004   	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the message. */
;;;1005   	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
000006  7f38              LDRB     r0,[r7,#0x1c]
000008  f0000001          AND      r0,r0,#1
00000c  b108              CBZ      r0,|L11.18|
;;;1006   	{
;;;1007   		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
00000e  2604              MOVS     r6,#4
000010  e000              B        |L11.20|
                  |L11.18|
;;;1008   	}
;;;1009   	else
;;;1010   	{
;;;1011   		xBytesToStoreMessageLength = 0;
000012  2600              MOVS     r6,#0
                  |L11.20|
;;;1012   	}
;;;1013   
;;;1014   	/* True if the available space equals zero. */
;;;1015   	if( xStreamBufferSpacesAvailable( xStreamBuffer ) <= xBytesToStoreMessageLength )
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       xStreamBufferSpacesAvailable
00001a  42b0              CMP      r0,r6
00001c  d801              BHI      |L11.34|
;;;1016   	{
;;;1017   		xReturn = pdTRUE;
00001e  2501              MOVS     r5,#1
000020  e000              B        |L11.36|
                  |L11.34|
;;;1018   	}
;;;1019   	else
;;;1020   	{
;;;1021   		xReturn = pdFALSE;
000022  2500              MOVS     r5,#0
                  |L11.36|
;;;1022   	}
;;;1023   
;;;1024   	return xReturn;
000024  4628              MOV      r0,r5
;;;1025   }
000026  bdf0              POP      {r4-r7,pc}
;;;1026   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xStreamBufferNextMessageLengthBytes||, CODE, READONLY, ALIGN=1

                  xStreamBufferNextMessageLengthBytes PROC
;;;816    
;;;817    size_t xStreamBufferNextMessageLengthBytes( StreamBufferHandle_t xStreamBuffer )
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;818    {
000004  4607              MOV      r7,r0
;;;819    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
000006  463c              MOV      r4,r7
;;;820    size_t xReturn, xBytesAvailable, xOriginalTail;
;;;821    configMESSAGE_BUFFER_LENGTH_TYPE xTempReturn;
;;;822    
;;;823    	configASSERT( pxStreamBuffer );
;;;824    
;;;825    	/* Ensure the stream buffer is being used as a message buffer. */
;;;826    	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
000008  7f20              LDRB     r0,[r4,#0x1c]
00000a  f0000001          AND      r0,r0,#1
00000e  b198              CBZ      r0,|L12.56|
;;;827    	{
;;;828    		xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       prvBytesInBuffer
000016  4606              MOV      r6,r0
;;;829    		if( xBytesAvailable > sbBYTES_TO_STORE_MESSAGE_LENGTH )
000018  2e04              CMP      r6,#4
00001a  d90b              BLS      |L12.52|
;;;830    		{
;;;831    			/* The number of bytes available is greater than the number of bytes
;;;832    			required to hold the length of the next message, so another message
;;;833    			is available.  Return its length without removing the length bytes
;;;834    			from the buffer.  A copy of the tail is stored so the buffer can be
;;;835    			returned to its prior state as the message is not actually being
;;;836    			removed from the buffer. */
;;;837    			xOriginalTail = pxStreamBuffer->xTail;
00001c  f8d48000          LDR      r8,[r4,#0]
;;;838    			( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempReturn, sbBYTES_TO_STORE_MESSAGE_LENGTH, xBytesAvailable );
000020  4633              MOV      r3,r6
000022  2204              MOVS     r2,#4
000024  4669              MOV      r1,sp
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       prvReadBytesFromBuffer
;;;839    			xReturn = ( size_t ) xTempReturn;
00002c  9d00              LDR      r5,[sp,#0]
;;;840    			pxStreamBuffer->xTail = xOriginalTail;
00002e  f8c48000          STR      r8,[r4,#0]
000032  e002              B        |L12.58|
                  |L12.52|
;;;841    		}
;;;842    		else
;;;843    		{
;;;844    			/* The minimum amount of bytes in a message buffer is
;;;845    			( sbBYTES_TO_STORE_MESSAGE_LENGTH + 1 ), so if xBytesAvailable is
;;;846    			less than sbBYTES_TO_STORE_MESSAGE_LENGTH the only other valid
;;;847    			value is 0. */
;;;848    			configASSERT( xBytesAvailable == 0 );
;;;849    			xReturn = 0;
000034  2500              MOVS     r5,#0
000036  e000              B        |L12.58|
                  |L12.56|
;;;850    		}
;;;851    	}
;;;852    	else
;;;853    	{
;;;854    		xReturn = 0;
000038  2500              MOVS     r5,#0
                  |L12.58|
;;;855    	}
;;;856    
;;;857    	return xReturn;
00003a  4628              MOV      r0,r5
;;;858    }
00003c  e8bd83f8          POP      {r3-r9,pc}
;;;859    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xStreamBufferReceive||, CODE, READONLY, ALIGN=1

                  xStreamBufferReceive PROC
;;;712    
;;;713    size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;714    							 void *pvRxData,
;;;715    							 size_t xBufferLengthBytes,
;;;716    							 TickType_t xTicksToWait )
;;;717    {
000004  4607              MOV      r7,r0
000006  468a              MOV      r10,r1
000008  4693              MOV      r11,r2
00000a  4698              MOV      r8,r3
;;;718    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
00000c  463c              MOV      r4,r7
;;;719    size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
00000e  f04f0900          MOV      r9,#0
;;;720    
;;;721    	configASSERT( pvRxData );
;;;722    	configASSERT( pxStreamBuffer );
;;;723    
;;;724    	/* This receive function is used by both message buffers, which store
;;;725    	discrete messages, and stream buffers, which store a continuous stream of
;;;726    	bytes.  Discrete messages include an additional
;;;727    	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
;;;728    	message. */
;;;729    	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
000012  7f20              LDRB     r0,[r4,#0x1c]
000014  f0000001          AND      r0,r0,#1
000018  b108              CBZ      r0,|L13.30|
;;;730    	{
;;;731    		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
00001a  2604              MOVS     r6,#4
00001c  e000              B        |L13.32|
                  |L13.30|
;;;732    	}
;;;733    	else
;;;734    	{
;;;735    		xBytesToStoreMessageLength = 0;
00001e  2600              MOVS     r6,#0
                  |L13.32|
;;;736    	}
;;;737    
;;;738    	if( xTicksToWait != ( TickType_t ) 0 )
000020  f1b80f00          CMP      r8,#0
000024  d01e              BEQ      |L13.100|
;;;739    	{
;;;740    		/* Checking if there is data and clearing the notification state must be
;;;741    		performed atomically. */
;;;742    		taskENTER_CRITICAL();
000026  f7fffffe          BL       vPortEnterCritical
;;;743    		{
;;;744    			xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       prvBytesInBuffer
000030  4605              MOV      r5,r0
;;;745    
;;;746    			/* If this function was invoked by a message buffer read then
;;;747    			xBytesToStoreMessageLength holds the number of bytes used to hold
;;;748    			the length of the next discrete message.  If this function was
;;;749    			invoked by a stream buffer read then xBytesToStoreMessageLength will
;;;750    			be 0. */
;;;751    			if( xBytesAvailable <= xBytesToStoreMessageLength )
000032  42b5              CMP      r5,r6
000034  d805              BHI      |L13.66|
;;;752    			{
;;;753    				/* Clear notification state as going to wait for data. */
;;;754    				( void ) xTaskNotifyStateClear( NULL );
000036  2000              MOVS     r0,#0
000038  f7fffffe          BL       xTaskNotifyStateClear
;;;755    
;;;756    				/* Should only be one reader. */
;;;757    				configASSERT( pxStreamBuffer->xTaskWaitingToReceive == NULL );
;;;758    				pxStreamBuffer->xTaskWaitingToReceive = xTaskGetCurrentTaskHandle();
00003c  f7fffffe          BL       xTaskGetCurrentTaskHandle
000040  6120              STR      r0,[r4,#0x10]
                  |L13.66|
;;;759    			}
;;;760    			else
;;;761    			{
;;;762    				mtCOVERAGE_TEST_MARKER();
;;;763    			}
;;;764    		}
;;;765    		taskEXIT_CRITICAL();
000042  f7fffffe          BL       vPortExitCritical
;;;766    
;;;767    		if( xBytesAvailable <= xBytesToStoreMessageLength )
000046  42b5              CMP      r5,r6
000048  d810              BHI      |L13.108|
;;;768    		{
;;;769    			/* Wait for data to be available. */
;;;770    			traceBLOCKING_ON_STREAM_BUFFER_RECEIVE( xStreamBuffer );
;;;771    			( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
00004a  4643              MOV      r3,r8
00004c  2200              MOVS     r2,#0
00004e  4611              MOV      r1,r2
000050  4610              MOV      r0,r2
000052  f7fffffe          BL       xTaskNotifyWait
;;;772    			pxStreamBuffer->xTaskWaitingToReceive = NULL;
000056  2000              MOVS     r0,#0
000058  6120              STR      r0,[r4,#0x10]
;;;773    
;;;774    			/* Recheck the data available after blocking. */
;;;775    			xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
00005a  4620              MOV      r0,r4
00005c  f7fffffe          BL       prvBytesInBuffer
000060  4605              MOV      r5,r0
000062  e003              B        |L13.108|
                  |L13.100|
;;;776    		}
;;;777    		else
;;;778    		{
;;;779    			mtCOVERAGE_TEST_MARKER();
;;;780    		}
;;;781    	}
;;;782    	else
;;;783    	{
;;;784    		xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
000064  4620              MOV      r0,r4
000066  f7fffffe          BL       prvBytesInBuffer
00006a  4605              MOV      r5,r0
                  |L13.108|
;;;785    	}
;;;786    
;;;787    	/* Whether receiving a discrete message (where xBytesToStoreMessageLength
;;;788    	holds the number of bytes used to store the message length) or a stream of
;;;789    	bytes (where xBytesToStoreMessageLength is zero), the number of bytes
;;;790    	available must be greater than xBytesToStoreMessageLength to be able to
;;;791    	read bytes from the buffer. */
;;;792    	if( xBytesAvailable > xBytesToStoreMessageLength )
00006c  42b5              CMP      r5,r6
00006e  d918              BLS      |L13.162|
;;;793    	{
;;;794    		xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
000070  462b              MOV      r3,r5
000072  465a              MOV      r2,r11
000074  4651              MOV      r1,r10
000076  4620              MOV      r0,r4
000078  9600              STR      r6,[sp,#0]
00007a  f7fffffe          BL       prvReadMessageFromBuffer
00007e  4681              MOV      r9,r0
;;;795    
;;;796    		/* Was a task waiting for space in the buffer? */
;;;797    		if( xReceivedLength != ( size_t ) 0 )
000080  f1b90f00          CMP      r9,#0
000084  d00d              BEQ      |L13.162|
;;;798    		{
;;;799    			traceSTREAM_BUFFER_RECEIVE( xStreamBuffer, xReceivedLength );
;;;800    			sbRECEIVE_COMPLETED( pxStreamBuffer );
000086  f7fffffe          BL       vTaskSuspendAll
00008a  6960              LDR      r0,[r4,#0x14]
00008c  b138              CBZ      r0,|L13.158|
00008e  6960              LDR      r0,[r4,#0x14]
000090  2300              MOVS     r3,#0
000092  461a              MOV      r2,r3
000094  4619              MOV      r1,r3
000096  f7fffffe          BL       xTaskGenericNotify
00009a  2000              MOVS     r0,#0
00009c  6160              STR      r0,[r4,#0x14]
                  |L13.158|
00009e  f7fffffe          BL       xTaskResumeAll
                  |L13.162|
;;;801    		}
;;;802    		else
;;;803    		{
;;;804    			mtCOVERAGE_TEST_MARKER();
;;;805    		}
;;;806    	}
;;;807    	else
;;;808    	{
;;;809    		traceSTREAM_BUFFER_RECEIVE_FAILED( xStreamBuffer );
;;;810    		mtCOVERAGE_TEST_MARKER();
;;;811    	}
;;;812    
;;;813    	return xReceivedLength;
0000a2  4648              MOV      r0,r9
;;;814    }
0000a4  e8bd8ff8          POP      {r3-r11,pc}
;;;815    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xStreamBufferReceiveCompletedFromISR||, CODE, READONLY, ALIGN=1

                  xStreamBufferReceiveCompletedFromISR PROC
;;;1057   
;;;1058   BaseType_t xStreamBufferReceiveCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken )
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;1059   {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
;;;1060   StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
000008  4625              MOV      r5,r4
;;;1061   BaseType_t xReturn;
;;;1062   UBaseType_t uxSavedInterruptStatus;
;;;1063   
;;;1064   	configASSERT( pxStreamBuffer );
;;;1065   
;;;1066   	uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
00000a  bf00              NOP      
00000c  21bf              MOVS     r1,#0xbf
00000e  f3ef8011          MRS      r0,BASEPRI
000012  f3818811          MSR      BASEPRI,r1
000016  f3bf8f4f          DSB      
00001a  f3bf8f6f          ISB      
00001e  bf00              NOP      
000020  4607              MOV      r7,r0
;;;1067   	{
;;;1068   		if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )
000022  6968              LDR      r0,[r5,#0x14]
000024  b158              CBZ      r0,|L14.62|
;;;1069   		{
;;;1070   			( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToSend,
000026  f8cd8000          STR      r8,[sp,#0]
00002a  6968              LDR      r0,[r5,#0x14]
00002c  2300              MOVS     r3,#0
00002e  461a              MOV      r2,r3
000030  4619              MOV      r1,r3
000032  f7fffffe          BL       xTaskGenericNotifyFromISR
;;;1071   										 ( uint32_t ) 0,
;;;1072   										 eNoAction,
;;;1073   										 pxHigherPriorityTaskWoken );
;;;1074   			( pxStreamBuffer )->xTaskWaitingToSend = NULL;
000036  2000              MOVS     r0,#0
000038  6168              STR      r0,[r5,#0x14]
;;;1075   			xReturn = pdTRUE;
00003a  2601              MOVS     r6,#1
00003c  e000              B        |L14.64|
                  |L14.62|
;;;1076   		}
;;;1077   		else
;;;1078   		{
;;;1079   			xReturn = pdFALSE;
00003e  2600              MOVS     r6,#0
                  |L14.64|
;;;1080   		}
;;;1081   	}
;;;1082   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
000040  bf00              NOP      
000042  f3878811          MSR      BASEPRI,r7
000046  bf00              NOP      
;;;1083   
;;;1084   	return xReturn;
000048  4630              MOV      r0,r6
;;;1085   }
00004a  e8bd83f8          POP      {r3-r9,pc}
;;;1086   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xStreamBufferReceiveFromISR||, CODE, READONLY, ALIGN=1

                  xStreamBufferReceiveFromISR PROC
;;;860    
;;;861    size_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;862    									void *pvRxData,
;;;863    									size_t xBufferLengthBytes,
;;;864    									BaseType_t * const pxHigherPriorityTaskWoken )
;;;865    {
000004  b081              SUB      sp,sp,#4
000006  4607              MOV      r7,r0
000008  468b              MOV      r11,r1
00000a  4699              MOV      r9,r3
;;;866    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
00000c  463c              MOV      r4,r7
;;;867    size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
00000e  f04f0a00          MOV      r10,#0
;;;868    
;;;869    	configASSERT( pvRxData );
;;;870    	configASSERT( pxStreamBuffer );
;;;871    
;;;872    	/* This receive function is used by both message buffers, which store
;;;873    	discrete messages, and stream buffers, which store a continuous stream of
;;;874    	bytes.  Discrete messages include an additional
;;;875    	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
;;;876    	message. */
;;;877    	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
000012  7f20              LDRB     r0,[r4,#0x1c]
000014  f0000001          AND      r0,r0,#1
000018  b108              CBZ      r0,|L15.30|
;;;878    	{
;;;879    		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
00001a  2604              MOVS     r6,#4
00001c  e000              B        |L15.32|
                  |L15.30|
;;;880    	}
;;;881    	else
;;;882    	{
;;;883    		xBytesToStoreMessageLength = 0;
00001e  2600              MOVS     r6,#0
                  |L15.32|
;;;884    	}
;;;885    
;;;886    	xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       prvBytesInBuffer
000026  4605              MOV      r5,r0
;;;887    
;;;888    	/* Whether receiving a discrete message (where xBytesToStoreMessageLength
;;;889    	holds the number of bytes used to store the message length) or a stream of
;;;890    	bytes (where xBytesToStoreMessageLength is zero), the number of bytes
;;;891    	available must be greater than xBytesToStoreMessageLength to be able to
;;;892    	read bytes from the buffer. */
;;;893    	if( xBytesAvailable > xBytesToStoreMessageLength )
000028  42b5              CMP      r5,r6
00002a  d927              BLS      |L15.124|
;;;894    	{
;;;895    		xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
00002c  462b              MOV      r3,r5
00002e  9600              STR      r6,[sp,#0]
000030  4659              MOV      r1,r11
000032  4620              MOV      r0,r4
000034  9a03              LDR      r2,[sp,#0xc]
000036  f7fffffe          BL       prvReadMessageFromBuffer
00003a  4682              MOV      r10,r0
;;;896    
;;;897    		/* Was a task waiting for space in the buffer? */
;;;898    		if( xReceivedLength != ( size_t ) 0 )
00003c  f1ba0f00          CMP      r10,#0
000040  d01c              BEQ      |L15.124|
;;;899    		{
;;;900    			sbRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
000042  bf00              NOP      
000044  21bf              MOVS     r1,#0xbf
000046  f3ef8011          MRS      r0,BASEPRI
00004a  f3818811          MSR      BASEPRI,r1
00004e  f3bf8f4f          DSB      
000052  f3bf8f6f          ISB      
000056  bf00              NOP      
000058  4680              MOV      r8,r0
00005a  6960              LDR      r0,[r4,#0x14]
00005c  b148              CBZ      r0,|L15.114|
00005e  f8cd9000          STR      r9,[sp,#0]
000062  6960              LDR      r0,[r4,#0x14]
000064  2300              MOVS     r3,#0
000066  461a              MOV      r2,r3
000068  4619              MOV      r1,r3
00006a  f7fffffe          BL       xTaskGenericNotifyFromISR
00006e  2000              MOVS     r0,#0
000070  6160              STR      r0,[r4,#0x14]
                  |L15.114|
000072  bf00              NOP      
000074  f3888811          MSR      BASEPRI,r8
000078  bf00              NOP      
00007a  bf00              NOP      
                  |L15.124|
;;;901    		}
;;;902    		else
;;;903    		{
;;;904    			mtCOVERAGE_TEST_MARKER();
;;;905    		}
;;;906    	}
;;;907    	else
;;;908    	{
;;;909    		mtCOVERAGE_TEST_MARKER();
;;;910    	}
;;;911    
;;;912    	traceSTREAM_BUFFER_RECEIVE_FROM_ISR( xStreamBuffer, xReceivedLength );
;;;913    
;;;914    	return xReceivedLength;
00007c  4650              MOV      r0,r10
;;;915    }
00007e  b005              ADD      sp,sp,#0x14
000080  e8bd8ff0          POP      {r4-r11,pc}
;;;916    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xStreamBufferReset||, CODE, READONLY, ALIGN=1

                  xStreamBufferReset PROC
;;;391    
;;;392    BaseType_t xStreamBufferReset( StreamBufferHandle_t xStreamBuffer )
000000  b5f8              PUSH     {r3-r7,lr}
;;;393    {
000002  4605              MOV      r5,r0
;;;394    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
000004  462c              MOV      r4,r5
;;;395    BaseType_t xReturn = pdFAIL;
000006  2600              MOVS     r6,#0
;;;396    
;;;397    #if( configUSE_TRACE_FACILITY == 1 )
;;;398    	UBaseType_t uxStreamBufferNumber;
;;;399    #endif
;;;400    
;;;401    	configASSERT( pxStreamBuffer );
;;;402    
;;;403    	#if( configUSE_TRACE_FACILITY == 1 )
;;;404    	{
;;;405    		/* Store the stream buffer number so it can be restored after the
;;;406    		reset. */
;;;407    		uxStreamBufferNumber = pxStreamBuffer->uxStreamBufferNumber;
;;;408    	}
;;;409    	#endif
;;;410    
;;;411    	/* Can only reset a message buffer if there are no tasks blocked on it. */
;;;412    	taskENTER_CRITICAL();
000008  f7fffffe          BL       vPortEnterCritical
;;;413    	{
;;;414    		if( pxStreamBuffer->xTaskWaitingToReceive == NULL )
00000c  6920              LDR      r0,[r4,#0x10]
00000e  b950              CBNZ     r0,|L16.38|
;;;415    		{
;;;416    			if( pxStreamBuffer->xTaskWaitingToSend == NULL )
000010  6960              LDR      r0,[r4,#0x14]
000012  b940              CBNZ     r0,|L16.38|
;;;417    			{
;;;418    				prvInitialiseNewStreamBuffer( pxStreamBuffer,
000014  7f20              LDRB     r0,[r4,#0x1c]
000016  9000              STR      r0,[sp,#0]
000018  4620              MOV      r0,r4
00001a  e9d42302          LDRD     r2,r3,[r4,#8]
00001e  69a1              LDR      r1,[r4,#0x18]
000020  f7fffffe          BL       prvInitialiseNewStreamBuffer
;;;419    											  pxStreamBuffer->pucBuffer,
;;;420    											  pxStreamBuffer->xLength,
;;;421    											  pxStreamBuffer->xTriggerLevelBytes,
;;;422    											  pxStreamBuffer->ucFlags );
;;;423    				xReturn = pdPASS;
000024  2601              MOVS     r6,#1
                  |L16.38|
;;;424    
;;;425    				#if( configUSE_TRACE_FACILITY == 1 )
;;;426    				{
;;;427    					pxStreamBuffer->uxStreamBufferNumber = uxStreamBufferNumber;
;;;428    				}
;;;429    				#endif
;;;430    
;;;431    				traceSTREAM_BUFFER_RESET( xStreamBuffer );
;;;432    			}
;;;433    		}
;;;434    	}
;;;435    	taskEXIT_CRITICAL();
000026  f7fffffe          BL       vPortExitCritical
;;;436    
;;;437    	return xReturn;
00002a  4630              MOV      r0,r6
;;;438    }
00002c  bdf8              POP      {r3-r7,pc}
;;;439    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xStreamBufferSend||, CODE, READONLY, ALIGN=1

                  xStreamBufferSend PROC
;;;505    
;;;506    size_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,
000000  e92d47ff          PUSH     {r0-r10,lr}
;;;507    						  const void *pvTxData,
;;;508    						  size_t xDataLengthBytes,
;;;509    						  TickType_t xTicksToWait )
;;;510    {
000004  b084              SUB      sp,sp,#0x10
000006  4605              MOV      r5,r0
000008  468a              MOV      r10,r1
00000a  4691              MOV      r9,r2
;;;511    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
00000c  462c              MOV      r4,r5
;;;512    size_t xReturn, xSpace = 0;
00000e  2700              MOVS     r7,#0
;;;513    size_t xRequiredSpace = xDataLengthBytes;
000010  46c8              MOV      r8,r9
;;;514    TimeOut_t xTimeOut;
;;;515    
;;;516    	configASSERT( pvTxData );
;;;517    	configASSERT( pxStreamBuffer );
;;;518    
;;;519    	/* This send function is used to write to both message buffers and stream
;;;520    	buffers.  If this is a message buffer then the space needed must be
;;;521    	increased by the amount of bytes needed to store the length of the
;;;522    	message. */
;;;523    	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
000012  7f20              LDRB     r0,[r4,#0x1c]
000014  f0000001          AND      r0,r0,#1
000018  b108              CBZ      r0,|L17.30|
;;;524    	{
;;;525    		xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
00001a  f1080804          ADD      r8,r8,#4
                  |L17.30|
;;;526    
;;;527    		/* Overflow? */
;;;528    		configASSERT( xRequiredSpace > xDataLengthBytes );
;;;529    	}
;;;530    	else
;;;531    	{
;;;532    		mtCOVERAGE_TEST_MARKER();
;;;533    	}
;;;534    
;;;535    	if( xTicksToWait != ( TickType_t ) 0 )
00001e  9807              LDR      r0,[sp,#0x1c]
000020  b330              CBZ      r0,|L17.112|
;;;536    	{
;;;537    		vTaskSetTimeOutState( &xTimeOut );
000022  a802              ADD      r0,sp,#8
000024  f7fffffe          BL       vTaskSetTimeOutState
;;;538    
;;;539    		do
000028  bf00              NOP      
                  |L17.42|
;;;540    		{
;;;541    			/* Wait until the required number of bytes are free in the message
;;;542    			buffer. */
;;;543    			taskENTER_CRITICAL();
00002a  f7fffffe          BL       vPortEnterCritical
;;;544    			{
;;;545    				xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       xStreamBufferSpacesAvailable
000034  4607              MOV      r7,r0
;;;546    
;;;547    				if( xSpace < xRequiredSpace )
000036  4547              CMP      r7,r8
000038  d206              BCS      |L17.72|
;;;548    				{
;;;549    					/* Clear notification state as going to wait for space. */
;;;550    					( void ) xTaskNotifyStateClear( NULL );
00003a  2000              MOVS     r0,#0
00003c  f7fffffe          BL       xTaskNotifyStateClear
;;;551    
;;;552    					/* Should only be one writer. */
;;;553    					configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
;;;554    					pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
000040  f7fffffe          BL       xTaskGetCurrentTaskHandle
000044  6160              STR      r0,[r4,#0x14]
000046  e002              B        |L17.78|
                  |L17.72|
;;;555    				}
;;;556    				else
;;;557    				{
;;;558    					taskEXIT_CRITICAL();
000048  f7fffffe          BL       vPortExitCritical
;;;559    					break;
00004c  e00f              B        |L17.110|
                  |L17.78|
;;;560    				}
;;;561    			}
;;;562    			taskEXIT_CRITICAL();
00004e  f7fffffe          BL       vPortExitCritical
;;;563    
;;;564    			traceBLOCKING_ON_STREAM_BUFFER_SEND( xStreamBuffer );
;;;565    			( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
000052  2200              MOVS     r2,#0
000054  4611              MOV      r1,r2
000056  4610              MOV      r0,r2
000058  9b07              LDR      r3,[sp,#0x1c]
00005a  f7fffffe          BL       xTaskNotifyWait
;;;566    			pxStreamBuffer->xTaskWaitingToSend = NULL;
00005e  2000              MOVS     r0,#0
000060  6160              STR      r0,[r4,#0x14]
;;;567    
;;;568    		} while( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE );
000062  a907              ADD      r1,sp,#0x1c
000064  a802              ADD      r0,sp,#8
000066  f7fffffe          BL       xTaskCheckForTimeOut
00006a  2800              CMP      r0,#0
00006c  d0dd              BEQ      |L17.42|
                  |L17.110|
00006e  bf00              NOP                            ;559
                  |L17.112|
;;;569    	}
;;;570    	else
;;;571    	{
;;;572    		mtCOVERAGE_TEST_MARKER();
;;;573    	}
;;;574    
;;;575    	if( xSpace == ( size_t ) 0 )
000070  b91f              CBNZ     r7,|L17.122|
;;;576    	{
;;;577    		xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
000072  4620              MOV      r0,r4
000074  f7fffffe          BL       xStreamBufferSpacesAvailable
000078  4607              MOV      r7,r0
                  |L17.122|
;;;578    	}
;;;579    	else
;;;580    	{
;;;581    		mtCOVERAGE_TEST_MARKER();
;;;582    	}
;;;583    
;;;584    	xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
00007a  463b              MOV      r3,r7
00007c  464a              MOV      r2,r9
00007e  4651              MOV      r1,r10
000080  4620              MOV      r0,r4
000082  f8cd8000          STR      r8,[sp,#0]
000086  f7fffffe          BL       prvWriteMessageToBuffer
00008a  4606              MOV      r6,r0
;;;585    
;;;586    	if( xReturn > ( size_t ) 0 )
00008c  b19e              CBZ      r6,|L17.182|
;;;587    	{
;;;588    		traceSTREAM_BUFFER_SEND( xStreamBuffer, xReturn );
;;;589    
;;;590    		/* Was a task waiting for the data? */
;;;591    		if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
00008e  4620              MOV      r0,r4
000090  f7fffffe          BL       prvBytesInBuffer
000094  68e1              LDR      r1,[r4,#0xc]
000096  4288              CMP      r0,r1
000098  d30d              BCC      |L17.182|
;;;592    		{
;;;593    			sbSEND_COMPLETED( pxStreamBuffer );
00009a  f7fffffe          BL       vTaskSuspendAll
00009e  6920              LDR      r0,[r4,#0x10]
0000a0  b138              CBZ      r0,|L17.178|
0000a2  6920              LDR      r0,[r4,#0x10]
0000a4  2300              MOVS     r3,#0
0000a6  461a              MOV      r2,r3
0000a8  4619              MOV      r1,r3
0000aa  f7fffffe          BL       xTaskGenericNotify
0000ae  2000              MOVS     r0,#0
0000b0  6120              STR      r0,[r4,#0x10]
                  |L17.178|
0000b2  f7fffffe          BL       xTaskResumeAll
                  |L17.182|
;;;594    		}
;;;595    		else
;;;596    		{
;;;597    			mtCOVERAGE_TEST_MARKER();
;;;598    		}
;;;599    	}
;;;600    	else
;;;601    	{
;;;602    		mtCOVERAGE_TEST_MARKER();
;;;603    		traceSTREAM_BUFFER_SEND_FAILED( xStreamBuffer );
;;;604    	}
;;;605    
;;;606    	return xReturn;
0000b6  4630              MOV      r0,r6
;;;607    }
0000b8  b008              ADD      sp,sp,#0x20
0000ba  e8bd87f0          POP      {r4-r10,pc}
;;;608    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xStreamBufferSendCompletedFromISR||, CODE, READONLY, ALIGN=1

                  xStreamBufferSendCompletedFromISR PROC
;;;1027   
;;;1028   BaseType_t xStreamBufferSendCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken )
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;1029   {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
;;;1030   StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
000008  4625              MOV      r5,r4
;;;1031   BaseType_t xReturn;
;;;1032   UBaseType_t uxSavedInterruptStatus;
;;;1033   
;;;1034   	configASSERT( pxStreamBuffer );
;;;1035   
;;;1036   	uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
00000a  bf00              NOP      
00000c  21bf              MOVS     r1,#0xbf
00000e  f3ef8011          MRS      r0,BASEPRI
000012  f3818811          MSR      BASEPRI,r1
000016  f3bf8f4f          DSB      
00001a  f3bf8f6f          ISB      
00001e  bf00              NOP      
000020  4607              MOV      r7,r0
;;;1037   	{
;;;1038   		if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )
000022  6928              LDR      r0,[r5,#0x10]
000024  b158              CBZ      r0,|L18.62|
;;;1039   		{
;;;1040   			( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive,
000026  f8cd8000          STR      r8,[sp,#0]
00002a  6928              LDR      r0,[r5,#0x10]
00002c  2300              MOVS     r3,#0
00002e  461a              MOV      r2,r3
000030  4619              MOV      r1,r3
000032  f7fffffe          BL       xTaskGenericNotifyFromISR
;;;1041   										 ( uint32_t ) 0,
;;;1042   										 eNoAction,
;;;1043   										 pxHigherPriorityTaskWoken );
;;;1044   			( pxStreamBuffer )->xTaskWaitingToReceive = NULL;
000036  2000              MOVS     r0,#0
000038  6128              STR      r0,[r5,#0x10]
;;;1045   			xReturn = pdTRUE;
00003a  2601              MOVS     r6,#1
00003c  e000              B        |L18.64|
                  |L18.62|
;;;1046   		}
;;;1047   		else
;;;1048   		{
;;;1049   			xReturn = pdFALSE;
00003e  2600              MOVS     r6,#0
                  |L18.64|
;;;1050   		}
;;;1051   	}
;;;1052   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
000040  bf00              NOP      
000042  f3878811          MSR      BASEPRI,r7
000046  bf00              NOP      
;;;1053   
;;;1054   	return xReturn;
000048  4630              MOV      r0,r6
;;;1055   }
00004a  e8bd83f8          POP      {r3-r9,pc}
;;;1056   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xStreamBufferSendFromISR||, CODE, READONLY, ALIGN=1

                  xStreamBufferSendFromISR PROC
;;;609    
;;;610    size_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;611    								 const void *pvTxData,
;;;612    								 size_t xDataLengthBytes,
;;;613    								 BaseType_t * const pxHigherPriorityTaskWoken )
;;;614    {
000004  4605              MOV      r5,r0
000006  468b              MOV      r11,r1
000008  4690              MOV      r8,r2
00000a  4699              MOV      r9,r3
;;;615    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
00000c  462c              MOV      r4,r5
;;;616    size_t xReturn, xSpace;
;;;617    size_t xRequiredSpace = xDataLengthBytes;
00000e  46c2              MOV      r10,r8
;;;618    
;;;619    	configASSERT( pvTxData );
;;;620    	configASSERT( pxStreamBuffer );
;;;621    
;;;622    	/* This send function is used to write to both message buffers and stream
;;;623    	buffers.  If this is a message buffer then the space needed must be
;;;624    	increased by the amount of bytes needed to store the length of the
;;;625    	message. */
;;;626    	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
000010  7f20              LDRB     r0,[r4,#0x1c]
000012  f0000001          AND      r0,r0,#1
000016  b108              CBZ      r0,|L19.28|
;;;627    	{
;;;628    		xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
000018  f10a0a04          ADD      r10,r10,#4
                  |L19.28|
;;;629    	}
;;;630    	else
;;;631    	{
;;;632    		mtCOVERAGE_TEST_MARKER();
;;;633    	}
;;;634    
;;;635    	xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       xStreamBufferSpacesAvailable
000022  9001              STR      r0,[sp,#4]
;;;636    	xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
000024  f8cda000          STR      r10,[sp,#0]
000028  4642              MOV      r2,r8
00002a  4659              MOV      r1,r11
00002c  4620              MOV      r0,r4
00002e  9b01              LDR      r3,[sp,#4]
000030  f7fffffe          BL       prvWriteMessageToBuffer
000034  4606              MOV      r6,r0
;;;637    
;;;638    	if( xReturn > ( size_t ) 0 )
000036  b316              CBZ      r6,|L19.126|
;;;639    	{
;;;640    		/* Was a task waiting for the data? */
;;;641    		if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       prvBytesInBuffer
00003e  68e1              LDR      r1,[r4,#0xc]
000040  4288              CMP      r0,r1
000042  d31c              BCC      |L19.126|
;;;642    		{
;;;643    			sbSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
000044  bf00              NOP      
000046  21bf              MOVS     r1,#0xbf
000048  f3ef8011          MRS      r0,BASEPRI
00004c  f3818811          MSR      BASEPRI,r1
000050  f3bf8f4f          DSB      
000054  f3bf8f6f          ISB      
000058  bf00              NOP      
00005a  4607              MOV      r7,r0
00005c  6920              LDR      r0,[r4,#0x10]
00005e  b148              CBZ      r0,|L19.116|
000060  f8cd9000          STR      r9,[sp,#0]
000064  6920              LDR      r0,[r4,#0x10]
000066  2300              MOVS     r3,#0
000068  461a              MOV      r2,r3
00006a  4619              MOV      r1,r3
00006c  f7fffffe          BL       xTaskGenericNotifyFromISR
000070  2000              MOVS     r0,#0
000072  6120              STR      r0,[r4,#0x10]
                  |L19.116|
000074  bf00              NOP      
000076  f3878811          MSR      BASEPRI,r7
00007a  bf00              NOP      
00007c  bf00              NOP      
                  |L19.126|
;;;644    		}
;;;645    		else
;;;646    		{
;;;647    			mtCOVERAGE_TEST_MARKER();
;;;648    		}
;;;649    	}
;;;650    	else
;;;651    	{
;;;652    		mtCOVERAGE_TEST_MARKER();
;;;653    	}
;;;654    
;;;655    	traceSTREAM_BUFFER_SEND_FROM_ISR( xStreamBuffer, xReturn );
;;;656    
;;;657    	return xReturn;
00007e  4630              MOV      r0,r6
;;;658    }
000080  e8bd9ffc          POP      {r2-r12,pc}
;;;659    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xStreamBufferSetTriggerLevel||, CODE, READONLY, ALIGN=1

                  xStreamBufferSetTriggerLevel PROC
;;;440    
;;;441    BaseType_t xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer, size_t xTriggerLevel )
000000  b510              PUSH     {r4,lr}
;;;442    {
000002  4602              MOV      r2,r0
;;;443    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
000004  4613              MOV      r3,r2
;;;444    BaseType_t xReturn;
;;;445    
;;;446    	configASSERT( pxStreamBuffer );
;;;447    
;;;448    	/* It is not valid for the trigger level to be 0. */
;;;449    	if( xTriggerLevel == ( size_t ) 0 )
000006  b901              CBNZ     r1,|L20.10|
;;;450    	{
;;;451    		xTriggerLevel = ( size_t ) 1;
000008  2101              MOVS     r1,#1
                  |L20.10|
;;;452    	}
;;;453    
;;;454    	/* The trigger level is the number of bytes that must be in the stream
;;;455    	buffer before a task that is waiting for data is unblocked. */
;;;456    	if( xTriggerLevel <= pxStreamBuffer->xLength )
00000a  689c              LDR      r4,[r3,#8]
00000c  428c              CMP      r4,r1
00000e  d302              BCC      |L20.22|
;;;457    	{
;;;458    		pxStreamBuffer->xTriggerLevelBytes = xTriggerLevel;
000010  60d9              STR      r1,[r3,#0xc]
;;;459    		xReturn = pdPASS;
000012  2001              MOVS     r0,#1
000014  e000              B        |L20.24|
                  |L20.22|
;;;460    	}
;;;461    	else
;;;462    	{
;;;463    		xReturn = pdFALSE;
000016  2000              MOVS     r0,#0
                  |L20.24|
;;;464    	}
;;;465    
;;;466    	return xReturn;
;;;467    }
000018  bd10              POP      {r4,pc}
;;;468    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xStreamBufferSpacesAvailable||, CODE, READONLY, ALIGN=1

                  xStreamBufferSpacesAvailable PROC
;;;469    
;;;470    size_t xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer )
000000  b510              PUSH     {r4,lr}
;;;471    {
000002  4601              MOV      r1,r0
;;;472    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
000004  460a              MOV      r2,r1
;;;473    size_t xSpace;
;;;474    
;;;475    	configASSERT( pxStreamBuffer );
;;;476    
;;;477    	xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
000006  6814              LDR      r4,[r2,#0]
000008  6893              LDR      r3,[r2,#8]
00000a  1918              ADDS     r0,r3,r4
;;;478    	xSpace -= pxStreamBuffer->xHead;
00000c  6853              LDR      r3,[r2,#4]
00000e  1ac0              SUBS     r0,r0,r3
;;;479    	xSpace -= ( size_t ) 1;
000010  1e40              SUBS     r0,r0,#1
;;;480    
;;;481    	if( xSpace >= pxStreamBuffer->xLength )
000012  6893              LDR      r3,[r2,#8]
000014  4283              CMP      r3,r0
000016  d801              BHI      |L21.28|
;;;482    	{
;;;483    		xSpace -= pxStreamBuffer->xLength;
000018  6893              LDR      r3,[r2,#8]
00001a  1ac0              SUBS     r0,r0,r3
                  |L21.28|
;;;484    	}
;;;485    	else
;;;486    	{
;;;487    		mtCOVERAGE_TEST_MARKER();
;;;488    	}
;;;489    
;;;490    	return xSpace;
;;;491    }
00001c  bd10              POP      {r4,pc}
;;;492    /*-----------------------------------------------------------*/
                          ENDP

