; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\queue.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\queue.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\User -I..\STM32F10x_StdPeriph_Libraries -I..\STM32F10x_StdPeriph_Libraries\STM32F10x_StdPeriph_Driver\src -I..\STM32F10x_StdPeriph_Libraries\STM32F10x_StdPeriph_Driver\inc -I..\STM32F10x_StdPeriph_Libraries\CMSIS\CM3\CoreSupport -I..\STM32F10x_StdPeriph_Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\STM32F10x_StdPeriph_Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\startup\arm -I..\FreeRTOS\Source -I..\FreeRTOS\Source\include -I..\FreeRTOS\Source\portable\RVDS\ARM_CM3 -I..\FreeRTOS\Source\portable\MemMang -I..\FreeRTOS -I..\User\Bsp -I..\SEGGER_RTT\RTT -I.\RTE\_Demo -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.0.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=523 -DSTM32F10X_MD -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER --omf_browse=.\objects\queue.crf ..\FreeRTOS\Source\queue.c]
                          THUMB

                          AREA ||i.prvCopyDataFromQueue||, CODE, READONLY, ALIGN=1

                  prvCopyDataFromQueue PROC
;;;2152   
;;;2153   static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
000000  b570              PUSH     {r4-r6,lr}
;;;2154   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2155   	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
000006  6c20              LDR      r0,[r4,#0x40]
000008  b170              CBZ      r0,|L1.40|
;;;2156   	{
;;;2157   		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
00000a  6c21              LDR      r1,[r4,#0x40]
00000c  68e0              LDR      r0,[r4,#0xc]
00000e  4401              ADD      r1,r1,r0
000010  60e1              STR      r1,[r4,#0xc]
;;;2158   		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
000012  e9d41002          LDRD     r1,r0,[r4,#8]
000016  4288              CMP      r0,r1
000018  d301              BCC      |L1.30|
;;;2159   		{
;;;2160   			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
00001a  6821              LDR      r1,[r4,#0]
00001c  60e1              STR      r1,[r4,#0xc]
                  |L1.30|
;;;2161   		}
;;;2162   		else
;;;2163   		{
;;;2164   			mtCOVERAGE_TEST_MARKER();
;;;2165   		}
;;;2166   		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
00001e  4628              MOV      r0,r5
000020  6c22              LDR      r2,[r4,#0x40]
000022  68e1              LDR      r1,[r4,#0xc]
000024  f7fffffe          BL       __aeabi_memcpy
                  |L1.40|
;;;2167   	}
;;;2168   }
000028  bd70              POP      {r4-r6,pc}
;;;2169   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvCopyDataToQueue||, CODE, READONLY, ALIGN=1

                  prvCopyDataToQueue PROC
;;;2073   
;;;2074   static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2075   {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
;;;2076   BaseType_t xReturn = pdFALSE;
00000a  f04f0800          MOV      r8,#0
;;;2077   UBaseType_t uxMessagesWaiting;
;;;2078   
;;;2079   	/* This function is called from a critical section. */
;;;2080   
;;;2081   	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
00000e  6ba6              LDR      r6,[r4,#0x38]
;;;2082   
;;;2083   	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
000010  6c20              LDR      r0,[r4,#0x40]
000012  b948              CBNZ     r0,|L2.40|
;;;2084   	{
;;;2085   		#if ( configUSE_MUTEXES == 1 )
;;;2086   		{
;;;2087   			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
000014  6820              LDR      r0,[r4,#0]
000016  2800              CMP      r0,#0
000018  d12c              BNE      |L2.116|
;;;2088   			{
;;;2089   				/* The mutex is no longer being held. */
;;;2090   				xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
00001a  68a0              LDR      r0,[r4,#8]
00001c  f7fffffe          BL       xTaskPriorityDisinherit
000020  4680              MOV      r8,r0
;;;2091   				pxQueue->u.xSemaphore.xMutexHolder = NULL;
000022  2000              MOVS     r0,#0
000024  60a0              STR      r0,[r4,#8]
000026  e025              B        |L2.116|
                  |L2.40|
;;;2092   			}
;;;2093   			else
;;;2094   			{
;;;2095   				mtCOVERAGE_TEST_MARKER();
;;;2096   			}
;;;2097   		}
;;;2098   		#endif /* configUSE_MUTEXES */
;;;2099   	}
;;;2100   	else if( xPosition == queueSEND_TO_BACK )
000028  b97d              CBNZ     r5,|L2.74|
;;;2101   	{
;;;2102   		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
00002a  4639              MOV      r1,r7
00002c  6c22              LDR      r2,[r4,#0x40]
00002e  6860              LDR      r0,[r4,#4]
000030  f7fffffe          BL       __aeabi_memcpy
;;;2103   		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
000034  6c21              LDR      r1,[r4,#0x40]
000036  6860              LDR      r0,[r4,#4]
000038  4408              ADD      r0,r0,r1
00003a  6060              STR      r0,[r4,#4]
;;;2104   		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
00003c  e9d40101          LDRD     r0,r1,[r4,#4]
000040  4288              CMP      r0,r1
000042  d317              BCC      |L2.116|
;;;2105   		{
;;;2106   			pxQueue->pcWriteTo = pxQueue->pcHead;
000044  6820              LDR      r0,[r4,#0]
000046  6060              STR      r0,[r4,#4]
000048  e014              B        |L2.116|
                  |L2.74|
;;;2107   		}
;;;2108   		else
;;;2109   		{
;;;2110   			mtCOVERAGE_TEST_MARKER();
;;;2111   		}
;;;2112   	}
;;;2113   	else
;;;2114   	{
;;;2115   		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
00004a  4639              MOV      r1,r7
00004c  6c22              LDR      r2,[r4,#0x40]
00004e  68e0              LDR      r0,[r4,#0xc]
000050  f7fffffe          BL       __aeabi_memcpy
;;;2116   		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
000054  6c21              LDR      r1,[r4,#0x40]
000056  68e0              LDR      r0,[r4,#0xc]
000058  1a41              SUBS     r1,r0,r1
00005a  60e1              STR      r1,[r4,#0xc]
;;;2117   		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
00005c  6821              LDR      r1,[r4,#0]
00005e  68e0              LDR      r0,[r4,#0xc]
000060  4288              CMP      r0,r1
000062  d203              BCS      |L2.108|
;;;2118   		{
;;;2119   			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
000064  6c21              LDR      r1,[r4,#0x40]
000066  68a0              LDR      r0,[r4,#8]
000068  1a41              SUBS     r1,r0,r1
00006a  60e1              STR      r1,[r4,#0xc]
                  |L2.108|
;;;2120   		}
;;;2121   		else
;;;2122   		{
;;;2123   			mtCOVERAGE_TEST_MARKER();
;;;2124   		}
;;;2125   
;;;2126   		if( xPosition == queueOVERWRITE )
00006c  2d02              CMP      r5,#2
00006e  d101              BNE      |L2.116|
;;;2127   		{
;;;2128   			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
000070  b106              CBZ      r6,|L2.116|
;;;2129   			{
;;;2130   				/* An item is not being added but overwritten, so subtract
;;;2131   				one from the recorded number of items in the queue so when
;;;2132   				one is added again below the number of recorded items remains
;;;2133   				correct. */
;;;2134   				--uxMessagesWaiting;
000072  1e76              SUBS     r6,r6,#1
                  |L2.116|
;;;2135   			}
;;;2136   			else
;;;2137   			{
;;;2138   				mtCOVERAGE_TEST_MARKER();
;;;2139   			}
;;;2140   		}
;;;2141   		else
;;;2142   		{
;;;2143   			mtCOVERAGE_TEST_MARKER();
;;;2144   		}
;;;2145   	}
;;;2146   
;;;2147   	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
000074  1c70              ADDS     r0,r6,#1
000076  63a0              STR      r0,[r4,#0x38]
;;;2148   
;;;2149   	return xReturn;
000078  4640              MOV      r0,r8
;;;2150   }
00007a  e8bd81f0          POP      {r4-r8,pc}
;;;2151   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvGetDisinheritPriorityAfterTimeout||, CODE, READONLY, ALIGN=1

                  prvGetDisinheritPriorityAfterTimeout PROC
;;;2048   
;;;2049   	static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )
000000  4601              MOV      r1,r0
;;;2050   	{
;;;2051   	UBaseType_t uxHighestPriorityOfWaitingTasks;
;;;2052   
;;;2053   		/* If a task waiting for a mutex causes the mutex holder to inherit a
;;;2054   		priority, but the waiting task times out, then the holder should
;;;2055   		disinherit the priority - but only down to the highest priority of any
;;;2056   		other tasks that are waiting for the same mutex.  For this purpose,
;;;2057   		return the priority of the highest priority task that is waiting for the
;;;2058   		mutex. */
;;;2059   		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
000002  6a4a              LDR      r2,[r1,#0x24]
000004  b122              CBZ      r2,|L3.16|
;;;2060   		{
;;;2061   			uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
000006  6b0a              LDR      r2,[r1,#0x30]
000008  6812              LDR      r2,[r2,#0]
00000a  f1c20003          RSB      r0,r2,#3
00000e  e000              B        |L3.18|
                  |L3.16|
;;;2062   		}
;;;2063   		else
;;;2064   		{
;;;2065   			uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
000010  2000              MOVS     r0,#0
                  |L3.18|
;;;2066   		}
;;;2067   
;;;2068   		return uxHighestPriorityOfWaitingTasks;
;;;2069   	}
000012  4770              BX       lr
;;;2070   
                          ENDP


                          AREA ||i.prvInitialiseMutex||, CODE, READONLY, ALIGN=1

                  prvInitialiseMutex PROC
;;;465    
;;;466    	static void prvInitialiseMutex( Queue_t *pxNewQueue )
000000  b510              PUSH     {r4,lr}
;;;467    	{
000002  4604              MOV      r4,r0
;;;468    		if( pxNewQueue != NULL )
000004  b154              CBZ      r4,|L4.28|
;;;469    		{
;;;470    			/* The queue create function will set all the queue structure members
;;;471    			correctly for a generic queue, but this function is creating a
;;;472    			mutex.  Overwrite those members that need to be set differently -
;;;473    			in particular the information required for priority inheritance. */
;;;474    			pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
000006  2000              MOVS     r0,#0
000008  60a0              STR      r0,[r4,#8]
;;;475    			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
00000a  6020              STR      r0,[r4,#0]
;;;476    
;;;477    			/* In case this is a recursive mutex. */
;;;478    			pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
00000c  2100              MOVS     r1,#0
00000e  60e1              STR      r1,[r4,#0xc]
;;;479    
;;;480    			traceCREATE_MUTEX( pxNewQueue );
;;;481    
;;;482    			/* Start with the semaphore in the expected state. */
;;;483    			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
000010  2300              MOVS     r3,#0
000012  461a              MOV      r2,r3
000014  4619              MOV      r1,r3
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       xQueueGenericSend
                  |L4.28|
;;;484    		}
;;;485    		else
;;;486    		{
;;;487    			traceCREATE_MUTEX_FAILED();
;;;488    		}
;;;489    	}
00001c  bd10              POP      {r4,pc}
;;;490    
                          ENDP


                          AREA ||i.prvInitialiseNewQueue||, CODE, READONLY, ALIGN=1

                  prvInitialiseNewQueue PROC
;;;421    
;;;422    static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;423    {
000004  4606              MOV      r6,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  9c06              LDR      r4,[sp,#0x18]
;;;424    	/* Remove compiler warnings about unused parameters should
;;;425    	configUSE_TRACE_FACILITY not be set to 1. */
;;;426    	( void ) ucQueueType;
;;;427    
;;;428    	if( uxItemSize == ( UBaseType_t ) 0 )
00000e  b90d              CBNZ     r5,|L5.20|
;;;429    	{
;;;430    		/* No RAM was allocated for the queue storage area, but PC head cannot
;;;431    		be set to NULL because NULL is used as a key to say the queue is used as
;;;432    		a mutex.  Therefore just set pcHead to point to the queue as a benign
;;;433    		value that is known to be within the memory map. */
;;;434    		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
000010  6024              STR      r4,[r4,#0]
000012  e000              B        |L5.22|
                  |L5.20|
;;;435    	}
;;;436    	else
;;;437    	{
;;;438    		/* Set the head to the start of the queue storage area. */
;;;439    		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
000014  6027              STR      r7,[r4,#0]
                  |L5.22|
;;;440    	}
;;;441    
;;;442    	/* Initialise the queue members as described where the queue type is
;;;443    	defined. */
;;;444    	pxNewQueue->uxLength = uxQueueLength;
000016  63e6              STR      r6,[r4,#0x3c]
;;;445    	pxNewQueue->uxItemSize = uxItemSize;
000018  6425              STR      r5,[r4,#0x40]
;;;446    	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
00001a  2101              MOVS     r1,#1
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       xQueueGenericReset
;;;447    
;;;448    	#if ( configUSE_TRACE_FACILITY == 1 )
;;;449    	{
;;;450    		pxNewQueue->ucQueueType = ucQueueType;
;;;451    	}
;;;452    	#endif /* configUSE_TRACE_FACILITY */
;;;453    
;;;454    	#if( configUSE_QUEUE_SETS == 1 )
;;;455    	{
;;;456    		pxNewQueue->pxQueueSetContainer = NULL;
;;;457    	}
;;;458    	#endif /* configUSE_QUEUE_SETS */
;;;459    
;;;460    	traceQUEUE_CREATE( pxNewQueue );
;;;461    }
000022  e8bd81f0          POP      {r4-r8,pc}
;;;462    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvIsQueueEmpty||, CODE, READONLY, ALIGN=1

                  prvIsQueueEmpty PROC
;;;2290   
;;;2291   static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
000000  b570              PUSH     {r4-r6,lr}
;;;2292   {
000002  4605              MOV      r5,r0
;;;2293   BaseType_t xReturn;
;;;2294   
;;;2295   	taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;2296   	{
;;;2297   		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
000008  6ba8              LDR      r0,[r5,#0x38]
00000a  b908              CBNZ     r0,|L6.16|
;;;2298   		{
;;;2299   			xReturn = pdTRUE;
00000c  2401              MOVS     r4,#1
00000e  e000              B        |L6.18|
                  |L6.16|
;;;2300   		}
;;;2301   		else
;;;2302   		{
;;;2303   			xReturn = pdFALSE;
000010  2400              MOVS     r4,#0
                  |L6.18|
;;;2304   		}
;;;2305   	}
;;;2306   	taskEXIT_CRITICAL();
000012  f7fffffe          BL       vPortExitCritical
;;;2307   
;;;2308   	return xReturn;
000016  4620              MOV      r0,r4
;;;2309   }
000018  bd70              POP      {r4-r6,pc}
;;;2310   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvIsQueueFull||, CODE, READONLY, ALIGN=1

                  prvIsQueueFull PROC
;;;2330   
;;;2331   static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
000000  b570              PUSH     {r4-r6,lr}
;;;2332   {
000002  4605              MOV      r5,r0
;;;2333   BaseType_t xReturn;
;;;2334   
;;;2335   	taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;2336   	{
;;;2337   		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
000008  6ba8              LDR      r0,[r5,#0x38]
00000a  6be9              LDR      r1,[r5,#0x3c]
00000c  4288              CMP      r0,r1
00000e  d101              BNE      |L7.20|
;;;2338   		{
;;;2339   			xReturn = pdTRUE;
000010  2401              MOVS     r4,#1
000012  e000              B        |L7.22|
                  |L7.20|
;;;2340   		}
;;;2341   		else
;;;2342   		{
;;;2343   			xReturn = pdFALSE;
000014  2400              MOVS     r4,#0
                  |L7.22|
;;;2344   		}
;;;2345   	}
;;;2346   	taskEXIT_CRITICAL();
000016  f7fffffe          BL       vPortExitCritical
;;;2347   
;;;2348   	return xReturn;
00001a  4620              MOV      r0,r4
;;;2349   }
00001c  bd70              POP      {r4-r6,pc}
;;;2350   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvUnlockQueue||, CODE, READONLY, ALIGN=1

                  prvUnlockQueue PROC
;;;2170   
;;;2171   static void prvUnlockQueue( Queue_t * const pxQueue )
000000  b570              PUSH     {r4-r6,lr}
;;;2172   {
000002  4604              MOV      r4,r0
;;;2173   	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
;;;2174   
;;;2175   	/* The lock counts contains the number of extra data items placed or
;;;2176   	removed from the queue while the queue was locked.  When a queue is
;;;2177   	locked items can be added or removed, but the event lists cannot be
;;;2178   	updated. */
;;;2179   	taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;2180   	{
;;;2181   		int8_t cTxLock = pxQueue->cTxLock;
000008  f9945045          LDRSB    r5,[r4,#0x45]
;;;2182   
;;;2183   		/* See if data was added to the queue while it was locked. */
;;;2184   		while( cTxLock > queueLOCKED_UNMODIFIED )
00000c  e010              B        |L8.48|
                  |L8.14|
;;;2185   		{
;;;2186   			/* Data was posted while the queue was locked.  Are any tasks
;;;2187   			blocked waiting for data to become available? */
;;;2188   			#if ( configUSE_QUEUE_SETS == 1 )
;;;2189   			{
;;;2190   				if( pxQueue->pxQueueSetContainer != NULL )
;;;2191   				{
;;;2192   					if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
;;;2193   					{
;;;2194   						/* The queue is a member of a queue set, and posting to
;;;2195   						the queue set caused a higher priority task to unblock.
;;;2196   						A context switch is required. */
;;;2197   						vTaskMissedYield();
;;;2198   					}
;;;2199   					else
;;;2200   					{
;;;2201   						mtCOVERAGE_TEST_MARKER();
;;;2202   					}
;;;2203   				}
;;;2204   				else
;;;2205   				{
;;;2206   					/* Tasks that are removed from the event list will get
;;;2207   					added to the pending ready list as the scheduler is still
;;;2208   					suspended. */
;;;2209   					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;2210   					{
;;;2211   						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;2212   						{
;;;2213   							/* The task waiting has a higher priority so record that a
;;;2214   							context	switch is required. */
;;;2215   							vTaskMissedYield();
;;;2216   						}
;;;2217   						else
;;;2218   						{
;;;2219   							mtCOVERAGE_TEST_MARKER();
;;;2220   						}
;;;2221   					}
;;;2222   					else
;;;2223   					{
;;;2224   						break;
;;;2225   					}
;;;2226   				}
;;;2227   			}
;;;2228   			#else /* configUSE_QUEUE_SETS */
;;;2229   			{
;;;2230   				/* Tasks that are removed from the event list will get added to
;;;2231   				the pending ready list as the scheduler is still suspended. */
;;;2232   				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
00000e  6a60              LDR      r0,[r4,#0x24]
000010  b908              CBNZ     r0,|L8.22|
000012  2001              MOVS     r0,#1
000014  e000              B        |L8.24|
                  |L8.22|
000016  2000              MOVS     r0,#0
                  |L8.24|
000018  b938              CBNZ     r0,|L8.42|
;;;2233   				{
;;;2234   					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
00001a  f1040024          ADD      r0,r4,#0x24
00001e  f7fffffe          BL       xTaskRemoveFromEventList
000022  b118              CBZ      r0,|L8.44|
;;;2235   					{
;;;2236   						/* The task waiting has a higher priority so record that
;;;2237   						a context switch is required. */
;;;2238   						vTaskMissedYield();
000024  f7fffffe          BL       vTaskMissedYield
000028  e000              B        |L8.44|
                  |L8.42|
;;;2239   					}
;;;2240   					else
;;;2241   					{
;;;2242   						mtCOVERAGE_TEST_MARKER();
;;;2243   					}
;;;2244   				}
;;;2245   				else
;;;2246   				{
;;;2247   					break;
00002a  e003              B        |L8.52|
                  |L8.44|
;;;2248   				}
;;;2249   			}
;;;2250   			#endif /* configUSE_QUEUE_SETS */
;;;2251   
;;;2252   			--cTxLock;
00002c  1e68              SUBS     r0,r5,#1
00002e  b245              SXTB     r5,r0
                  |L8.48|
000030  2d00              CMP      r5,#0                 ;2184
000032  dcec              BGT      |L8.14|
                  |L8.52|
000034  bf00              NOP                            ;2247
;;;2253   		}
;;;2254   
;;;2255   		pxQueue->cTxLock = queueUNLOCKED;
000036  20ff              MOVS     r0,#0xff
000038  f8840045          STRB     r0,[r4,#0x45]
;;;2256   	}
;;;2257   	taskEXIT_CRITICAL();
00003c  f7fffffe          BL       vPortExitCritical
;;;2258   
;;;2259   	/* Do the same for the Rx lock. */
;;;2260   	taskENTER_CRITICAL();
000040  f7fffffe          BL       vPortEnterCritical
;;;2261   	{
;;;2262   		int8_t cRxLock = pxQueue->cRxLock;
000044  f9945044          LDRSB    r5,[r4,#0x44]
;;;2263   
;;;2264   		while( cRxLock > queueLOCKED_UNMODIFIED )
000048  e010              B        |L8.108|
                  |L8.74|
;;;2265   		{
;;;2266   			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
00004a  6920              LDR      r0,[r4,#0x10]
00004c  b908              CBNZ     r0,|L8.82|
00004e  2001              MOVS     r0,#1
000050  e000              B        |L8.84|
                  |L8.82|
000052  2000              MOVS     r0,#0
                  |L8.84|
000054  b948              CBNZ     r0,|L8.106|
;;;2267   			{
;;;2268   				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
000056  f1040010          ADD      r0,r4,#0x10
00005a  f7fffffe          BL       xTaskRemoveFromEventList
00005e  b108              CBZ      r0,|L8.100|
;;;2269   				{
;;;2270   					vTaskMissedYield();
000060  f7fffffe          BL       vTaskMissedYield
                  |L8.100|
;;;2271   				}
;;;2272   				else
;;;2273   				{
;;;2274   					mtCOVERAGE_TEST_MARKER();
;;;2275   				}
;;;2276   
;;;2277   				--cRxLock;
000064  1e68              SUBS     r0,r5,#1
000066  b245              SXTB     r5,r0
000068  e000              B        |L8.108|
                  |L8.106|
;;;2278   			}
;;;2279   			else
;;;2280   			{
;;;2281   				break;
00006a  e001              B        |L8.112|
                  |L8.108|
00006c  2d00              CMP      r5,#0                 ;2264
00006e  dcec              BGT      |L8.74|
                  |L8.112|
000070  bf00              NOP      
;;;2282   			}
;;;2283   		}
;;;2284   
;;;2285   		pxQueue->cRxLock = queueUNLOCKED;
000072  20ff              MOVS     r0,#0xff
000074  f8840044          STRB     r0,[r4,#0x44]
;;;2286   	}
;;;2287   	taskEXIT_CRITICAL();
000078  f7fffffe          BL       vPortExitCritical
;;;2288   }
00007c  bd70              POP      {r4-r6,pc}
;;;2289   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.uxQueueMessagesWaiting||, CODE, READONLY, ALIGN=1

                  uxQueueMessagesWaiting PROC
;;;1929   
;;;1930   UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
000000  b570              PUSH     {r4-r6,lr}
;;;1931   {
000002  4604              MOV      r4,r0
;;;1932   UBaseType_t uxReturn;
;;;1933   
;;;1934   	configASSERT( xQueue );
;;;1935   
;;;1936   	taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;1937   	{
;;;1938   		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
000008  6ba5              LDR      r5,[r4,#0x38]
;;;1939   	}
;;;1940   	taskEXIT_CRITICAL();
00000a  f7fffffe          BL       vPortExitCritical
;;;1941   
;;;1942   	return uxReturn;
00000e  4628              MOV      r0,r5
;;;1943   } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
000010  bd70              POP      {r4-r6,pc}
;;;1944   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.uxQueueMessagesWaitingFromISR||, CODE, READONLY, ALIGN=1

                  uxQueueMessagesWaitingFromISR PROC
;;;1962   
;;;1963   UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
000000  4601              MOV      r1,r0
;;;1964   {
;;;1965   UBaseType_t uxReturn;
;;;1966   Queue_t * const pxQueue = xQueue;
000002  460a              MOV      r2,r1
;;;1967   
;;;1968   	configASSERT( pxQueue );
;;;1969   	uxReturn = pxQueue->uxMessagesWaiting;
000004  6b90              LDR      r0,[r2,#0x38]
;;;1970   
;;;1971   	return uxReturn;
;;;1972   } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
000006  4770              BX       lr
;;;1973   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.uxQueueSpacesAvailable||, CODE, READONLY, ALIGN=1

                  uxQueueSpacesAvailable PROC
;;;1945   
;;;1946   UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
000000  b570              PUSH     {r4-r6,lr}
;;;1947   {
000002  4604              MOV      r4,r0
;;;1948   UBaseType_t uxReturn;
;;;1949   Queue_t * const pxQueue = xQueue;
000004  4625              MOV      r5,r4
;;;1950   
;;;1951   	configASSERT( pxQueue );
;;;1952   
;;;1953   	taskENTER_CRITICAL();
000006  f7fffffe          BL       vPortEnterCritical
;;;1954   	{
;;;1955   		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
00000a  e9d5100e          LDRD     r1,r0,[r5,#0x38]
00000e  1a46              SUBS     r6,r0,r1
;;;1956   	}
;;;1957   	taskEXIT_CRITICAL();
000010  f7fffffe          BL       vPortExitCritical
;;;1958   
;;;1959   	return uxReturn;
000014  4630              MOV      r0,r6
;;;1960   } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
000016  bd70              POP      {r4-r6,pc}
;;;1961   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.vQueueDelete||, CODE, READONLY, ALIGN=1

                  vQueueDelete PROC
;;;1974   
;;;1975   void vQueueDelete( QueueHandle_t xQueue )
000000  b570              PUSH     {r4-r6,lr}
;;;1976   {
000002  4604              MOV      r4,r0
;;;1977   Queue_t * const pxQueue = xQueue;
000004  4625              MOV      r5,r4
;;;1978   
;;;1979   	configASSERT( pxQueue );
;;;1980   	traceQUEUE_DELETE( pxQueue );
;;;1981   
;;;1982   	#if ( configQUEUE_REGISTRY_SIZE > 0 )
;;;1983   	{
;;;1984   		vQueueUnregisterQueue( pxQueue );
;;;1985   	}
;;;1986   	#endif
;;;1987   
;;;1988   	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
;;;1989   	{
;;;1990   		/* The queue can only have been allocated dynamically - free it
;;;1991   		again. */
;;;1992   		vPortFree( pxQueue );
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       vPortFree
;;;1993   	}
;;;1994   	#elif( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
;;;1995   	{
;;;1996   		/* The queue could have been allocated statically or dynamically, so
;;;1997   		check before attempting to free the memory. */
;;;1998   		if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
;;;1999   		{
;;;2000   			vPortFree( pxQueue );
;;;2001   		}
;;;2002   		else
;;;2003   		{
;;;2004   			mtCOVERAGE_TEST_MARKER();
;;;2005   		}
;;;2006   	}
;;;2007   	#else
;;;2008   	{
;;;2009   		/* The queue must have been statically allocated, so is not going to be
;;;2010   		deleted.  Avoid compiler warnings about the unused parameter. */
;;;2011   		( void ) pxQueue;
;;;2012   	}
;;;2013   	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
;;;2014   }
00000c  bd70              POP      {r4-r6,pc}
;;;2015   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueueCreateMutex||, CODE, READONLY, ALIGN=1

                  xQueueCreateMutex PROC
;;;495    
;;;496    	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;497    	{
000004  4604              MOV      r4,r0
;;;498    	QueueHandle_t xNewQueue;
;;;499    	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
000006  2601              MOVS     r6,#1
000008  2700              MOVS     r7,#0
;;;500    
;;;501    		xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
00000a  4622              MOV      r2,r4
00000c  2100              MOVS     r1,#0
00000e  2001              MOVS     r0,#1
000010  f7fffffe          BL       xQueueGenericCreate
000014  4605              MOV      r5,r0
;;;502    		prvInitialiseMutex( ( Queue_t * ) xNewQueue );
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       prvInitialiseMutex
;;;503    
;;;504    		return xNewQueue;
00001c  4628              MOV      r0,r5
;;;505    	}
00001e  e8bd81f0          POP      {r4-r8,pc}
;;;506    
                          ENDP


                          AREA ||i.xQueueGenericCreate||, CODE, READONLY, ALIGN=1

                  xQueueGenericCreate PROC
;;;367    
;;;368    	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;369    	{
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;370    	Queue_t *pxNewQueue;
;;;371    	size_t xQueueSizeInBytes;
;;;372    	uint8_t *pucQueueStorage;
;;;373    
;;;374    		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
;;;375    
;;;376    		/* Allocate enough space to hold the maximum number of items that
;;;377    		can be in the queue at any time.  It is valid for uxItemSize to be
;;;378    		zero in the case the queue is used as a semaphore. */
;;;379    		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
00000a  fb05f906          MUL      r9,r5,r6
;;;380    
;;;381    		/* Allocate the queue and storage area.  Justification for MISRA
;;;382    		deviation as follows:  pvPortMalloc() always ensures returned memory
;;;383    		blocks are aligned per the requirements of the MCU stack.  In this case
;;;384    		pvPortMalloc() must return a pointer that is guaranteed to meet the
;;;385    		alignment requirements of the Queue_t structure - which in this case
;;;386    		is an int8_t *.  Therefore, whenever the stack alignment requirements
;;;387    		are greater than or equal to the pointer to char requirements the cast
;;;388    		is safe.  In other cases alignment requirements are not strict (one or
;;;389    		two bytes). */
;;;390    		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
00000e  f1090048          ADD      r0,r9,#0x48
000012  f7fffffe          BL       pvPortMalloc
000016  4604              MOV      r4,r0
;;;391    
;;;392    		if( pxNewQueue != NULL )
000018  b14c              CBZ      r4,|L14.46|
;;;393    		{
;;;394    			/* Jump past the queue structure to find the location of the queue
;;;395    			storage area. */
;;;396    			pucQueueStorage = ( uint8_t * ) pxNewQueue;
00001a  46a0              MOV      r8,r4
;;;397    			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
00001c  f1080848          ADD      r8,r8,#0x48
;;;398    
;;;399    			#if( configSUPPORT_STATIC_ALLOCATION == 1 )
;;;400    			{
;;;401    				/* Queues can be created either statically or dynamically, so
;;;402    				note this task was created dynamically in case it is later
;;;403    				deleted. */
;;;404    				pxNewQueue->ucStaticallyAllocated = pdFALSE;
;;;405    			}
;;;406    			#endif /* configSUPPORT_STATIC_ALLOCATION */
;;;407    
;;;408    			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
000020  463b              MOV      r3,r7
000022  4642              MOV      r2,r8
000024  4631              MOV      r1,r6
000026  4628              MOV      r0,r5
000028  9400              STR      r4,[sp,#0]
00002a  f7fffffe          BL       prvInitialiseNewQueue
                  |L14.46|
;;;409    		}
;;;410    		else
;;;411    		{
;;;412    			traceQUEUE_CREATE_FAILED( ucQueueType );
;;;413    			mtCOVERAGE_TEST_MARKER();
;;;414    		}
;;;415    
;;;416    		return pxNewQueue;
00002e  4620              MOV      r0,r4
;;;417    	}
000030  e8bd83f8          POP      {r3-r9,pc}
;;;418    
                          ENDP


                          AREA ||i.xQueueGenericReset||, CODE, READONLY, ALIGN=2

                  xQueueGenericReset PROC
;;;254    
;;;255    BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
000000  b570              PUSH     {r4-r6,lr}
;;;256    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;257    Queue_t * const pxQueue = xQueue;
000006  462c              MOV      r4,r5
;;;258    
;;;259    	configASSERT( pxQueue );
;;;260    
;;;261    	taskENTER_CRITICAL();
000008  f7fffffe          BL       vPortEnterCritical
;;;262    	{
;;;263    		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
00000c  e9d4120f          LDRD     r1,r2,[r4,#0x3c]
000010  6820              LDR      r0,[r4,#0]
000012  fb010002          MLA      r0,r1,r2,r0
000016  60a0              STR      r0,[r4,#8]
;;;264    		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
000018  2000              MOVS     r0,#0
00001a  63a0              STR      r0,[r4,#0x38]
;;;265    		pxQueue->pcWriteTo = pxQueue->pcHead;
00001c  6820              LDR      r0,[r4,#0]
00001e  6060              STR      r0,[r4,#4]
;;;266    		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
000020  6be0              LDR      r0,[r4,#0x3c]
000022  1e40              SUBS     r0,r0,#1
000024  6c22              LDR      r2,[r4,#0x40]
000026  6821              LDR      r1,[r4,#0]
000028  fb001102          MLA      r1,r0,r2,r1
00002c  60e1              STR      r1,[r4,#0xc]
;;;267    		pxQueue->cRxLock = queueUNLOCKED;
00002e  20ff              MOVS     r0,#0xff
000030  f8840044          STRB     r0,[r4,#0x44]
;;;268    		pxQueue->cTxLock = queueUNLOCKED;
000034  f8840045          STRB     r0,[r4,#0x45]
;;;269    
;;;270    		if( xNewQueue == pdFALSE )
000038  b99e              CBNZ     r6,|L15.98|
;;;271    		{
;;;272    			/* If there are tasks blocked waiting to read from the queue, then
;;;273    			the tasks will remain blocked as after this function exits the queue
;;;274    			will still be empty.  If there are tasks blocked waiting to write to
;;;275    			the queue, then one should be unblocked as after this function exits
;;;276    			it will be possible to write to it. */
;;;277    			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
00003a  6920              LDR      r0,[r4,#0x10]
00003c  b908              CBNZ     r0,|L15.66|
00003e  2001              MOVS     r0,#1
000040  e000              B        |L15.68|
                  |L15.66|
000042  2000              MOVS     r0,#0
                  |L15.68|
000044  b9a8              CBNZ     r0,|L15.114|
;;;278    			{
;;;279    				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
000046  f1040010          ADD      r0,r4,#0x10
00004a  f7fffffe          BL       xTaskRemoveFromEventList
00004e  b180              CBZ      r0,|L15.114|
;;;280    				{
;;;281    					queueYIELD_IF_USING_PREEMPTION();
000050  f04f5080          MOV      r0,#0x10000000
000054  4909              LDR      r1,|L15.124|
000056  6008              STR      r0,[r1,#0]
000058  f3bf8f4f          DSB      
00005c  f3bf8f6f          ISB      
000060  e007              B        |L15.114|
                  |L15.98|
;;;282    				}
;;;283    				else
;;;284    				{
;;;285    					mtCOVERAGE_TEST_MARKER();
;;;286    				}
;;;287    			}
;;;288    			else
;;;289    			{
;;;290    				mtCOVERAGE_TEST_MARKER();
;;;291    			}
;;;292    		}
;;;293    		else
;;;294    		{
;;;295    			/* Ensure the event queues start in the correct state. */
;;;296    			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
000062  f1040010          ADD      r0,r4,#0x10
000066  f7fffffe          BL       vListInitialise
;;;297    			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
00006a  f1040024          ADD      r0,r4,#0x24
00006e  f7fffffe          BL       vListInitialise
                  |L15.114|
;;;298    		}
;;;299    	}
;;;300    	taskEXIT_CRITICAL();
000072  f7fffffe          BL       vPortExitCritical
;;;301    
;;;302    	/* A value is returned for calling semantic consistency with previous
;;;303    	versions. */
;;;304    	return pdPASS;
000076  2001              MOVS     r0,#1
;;;305    }
000078  bd70              POP      {r4-r6,pc}
;;;306    /*-----------------------------------------------------------*/
                          ENDP

00007a  0000              DCW      0x0000
                  |L15.124|
                          DCD      0xe000ed04

                          AREA ||i.xQueueGenericSend||, CODE, READONLY, ALIGN=2

                  xQueueGenericSend PROC
;;;739    
;;;740    BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
000000  e92d43ff          PUSH     {r0-r9,lr}
;;;741    {
000004  b083              SUB      sp,sp,#0xc
000006  4607              MOV      r7,r0
000008  4688              MOV      r8,r1
00000a  461d              MOV      r5,r3
;;;742    BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
00000c  f04f0900          MOV      r9,#0
;;;743    TimeOut_t xTimeOut;
;;;744    Queue_t * const pxQueue = xQueue;
000010  463c              MOV      r4,r7
;;;745    
;;;746    	configASSERT( pxQueue );
;;;747    	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
;;;748    	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
;;;749    	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
;;;750    	{
;;;751    		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
;;;752    	}
;;;753    	#endif
;;;754    
;;;755    
;;;756    	/*lint -save -e904 This function relaxes the coding standard somewhat to
;;;757    	allow return statements within the function itself.  This is done in the
;;;758    	interest of execution time efficiency. */
;;;759    	for( ;; )
000012  bf00              NOP      
                  |L16.20|
;;;760    	{
;;;761    		taskENTER_CRITICAL();
000014  f7fffffe          BL       vPortEnterCritical
;;;762    		{
;;;763    			/* Is there room on the queue now?  The running task must be the
;;;764    			highest priority task wanting to access the queue.  If the head item
;;;765    			in the queue is to be overwritten then it does not matter if the
;;;766    			queue is full. */
;;;767    			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
000018  6ba0              LDR      r0,[r4,#0x38]
00001a  6be1              LDR      r1,[r4,#0x3c]
00001c  4288              CMP      r0,r1
00001e  d301              BCC      |L16.36|
000020  2d02              CMP      r5,#2
000022  d128              BNE      |L16.118|
                  |L16.36|
;;;768    			{
;;;769    				traceQUEUE_SEND( pxQueue );
;;;770    
;;;771    				#if ( configUSE_QUEUE_SETS == 1 )
;;;772    				{
;;;773    				const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
;;;774    
;;;775    					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
;;;776    
;;;777    					if( pxQueue->pxQueueSetContainer != NULL )
;;;778    					{
;;;779    						if( ( xCopyPosition == queueOVERWRITE ) && ( uxPreviousMessagesWaiting != ( UBaseType_t ) 0 ) )
;;;780    						{
;;;781    							/* Do not notify the queue set as an existing item
;;;782    							was overwritten in the queue so the number of items
;;;783    							in the queue has not changed. */
;;;784    							mtCOVERAGE_TEST_MARKER();
;;;785    						}
;;;786    						else if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
;;;787    						{
;;;788    							/* The queue is a member of a queue set, and posting
;;;789    							to the queue set caused a higher priority task to
;;;790    							unblock. A context switch is required. */
;;;791    							queueYIELD_IF_USING_PREEMPTION();
;;;792    						}
;;;793    						else
;;;794    						{
;;;795    							mtCOVERAGE_TEST_MARKER();
;;;796    						}
;;;797    					}
;;;798    					else
;;;799    					{
;;;800    						/* If there was a task waiting for data to arrive on the
;;;801    						queue then unblock it now. */
;;;802    						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;803    						{
;;;804    							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;805    							{
;;;806    								/* The unblocked task has a priority higher than
;;;807    								our own so yield immediately.  Yes it is ok to
;;;808    								do this from within the critical section - the
;;;809    								kernel takes care of that. */
;;;810    								queueYIELD_IF_USING_PREEMPTION();
;;;811    							}
;;;812    							else
;;;813    							{
;;;814    								mtCOVERAGE_TEST_MARKER();
;;;815    							}
;;;816    						}
;;;817    						else if( xYieldRequired != pdFALSE )
;;;818    						{
;;;819    							/* This path is a special case that will only get
;;;820    							executed if the task was holding multiple mutexes
;;;821    							and the mutexes were given back in an order that is
;;;822    							different to that in which they were taken. */
;;;823    							queueYIELD_IF_USING_PREEMPTION();
;;;824    						}
;;;825    						else
;;;826    						{
;;;827    							mtCOVERAGE_TEST_MARKER();
;;;828    						}
;;;829    					}
;;;830    				}
;;;831    				#else /* configUSE_QUEUE_SETS */
;;;832    				{
;;;833    					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
000024  462a              MOV      r2,r5
000026  4641              MOV      r1,r8
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       prvCopyDataToQueue
00002e  4606              MOV      r6,r0
;;;834    
;;;835    					/* If there was a task waiting for data to arrive on the
;;;836    					queue then unblock it now. */
;;;837    					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
000030  6a60              LDR      r0,[r4,#0x24]
000032  b908              CBNZ     r0,|L16.56|
000034  2001              MOVS     r0,#1
000036  e000              B        |L16.58|
                  |L16.56|
000038  2000              MOVS     r0,#0
                  |L16.58|
00003a  b968              CBNZ     r0,|L16.88|
;;;838    					{
;;;839    						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
00003c  f1040024          ADD      r0,r4,#0x24
000040  f7fffffe          BL       xTaskRemoveFromEventList
000044  b188              CBZ      r0,|L16.106|
;;;840    						{
;;;841    							/* The unblocked task has a priority higher than
;;;842    							our own so yield immediately.  Yes it is ok to do
;;;843    							this from within the critical section - the kernel
;;;844    							takes care of that. */
;;;845    							queueYIELD_IF_USING_PREEMPTION();
000046  f04f5080          MOV      r0,#0x10000000
00004a  4932              LDR      r1,|L16.276|
00004c  6008              STR      r0,[r1,#0]
00004e  f3bf8f4f          DSB      
000052  f3bf8f6f          ISB      
000056  e008              B        |L16.106|
                  |L16.88|
;;;846    						}
;;;847    						else
;;;848    						{
;;;849    							mtCOVERAGE_TEST_MARKER();
;;;850    						}
;;;851    					}
;;;852    					else if( xYieldRequired != pdFALSE )
000058  b13e              CBZ      r6,|L16.106|
;;;853    					{
;;;854    						/* This path is a special case that will only get
;;;855    						executed if the task was holding multiple mutexes and
;;;856    						the mutexes were given back in an order that is
;;;857    						different to that in which they were taken. */
;;;858    						queueYIELD_IF_USING_PREEMPTION();
00005a  f04f5080          MOV      r0,#0x10000000
00005e  492d              LDR      r1,|L16.276|
000060  6008              STR      r0,[r1,#0]
000062  f3bf8f4f          DSB      
000066  f3bf8f6f          ISB      
                  |L16.106|
;;;859    					}
;;;860    					else
;;;861    					{
;;;862    						mtCOVERAGE_TEST_MARKER();
;;;863    					}
;;;864    				}
;;;865    				#endif /* configUSE_QUEUE_SETS */
;;;866    
;;;867    				taskEXIT_CRITICAL();
00006a  f7fffffe          BL       vPortExitCritical
;;;868    				return pdPASS;
00006e  2001              MOVS     r0,#1
                  |L16.112|
;;;869    			}
;;;870    			else
;;;871    			{
;;;872    				if( xTicksToWait == ( TickType_t ) 0 )
;;;873    				{
;;;874    					/* The queue was full and no block time is specified (or
;;;875    					the block time has expired) so leave now. */
;;;876    					taskEXIT_CRITICAL();
;;;877    
;;;878    					/* Return to the original privilege level before exiting
;;;879    					the function. */
;;;880    					traceQUEUE_SEND_FAILED( pxQueue );
;;;881    					return errQUEUE_FULL;
;;;882    				}
;;;883    				else if( xEntryTimeSet == pdFALSE )
;;;884    				{
;;;885    					/* The queue was full and a block time was specified so
;;;886    					configure the timeout structure. */
;;;887    					vTaskInternalSetTimeOutState( &xTimeOut );
;;;888    					xEntryTimeSet = pdTRUE;
;;;889    				}
;;;890    				else
;;;891    				{
;;;892    					/* Entry time was already set. */
;;;893    					mtCOVERAGE_TEST_MARKER();
;;;894    				}
;;;895    			}
;;;896    		}
;;;897    		taskEXIT_CRITICAL();
;;;898    
;;;899    		/* Interrupts and other tasks can send to and receive from the queue
;;;900    		now the critical section has been exited. */
;;;901    
;;;902    		vTaskSuspendAll();
;;;903    		prvLockQueue( pxQueue );
;;;904    
;;;905    		/* Update the timeout state to see if it has expired yet. */
;;;906    		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
;;;907    		{
;;;908    			if( prvIsQueueFull( pxQueue ) != pdFALSE )
;;;909    			{
;;;910    				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
;;;911    				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
;;;912    
;;;913    				/* Unlocking the queue means queue events can effect the
;;;914    				event list.  It is possible that interrupts occurring now
;;;915    				remove this task from the event list again - but as the
;;;916    				scheduler is suspended the task will go onto the pending
;;;917    				ready last instead of the actual ready list. */
;;;918    				prvUnlockQueue( pxQueue );
;;;919    
;;;920    				/* Resuming the scheduler will move tasks from the pending
;;;921    				ready list into the ready list - so it is feasible that this
;;;922    				task is already in a ready list before it yields - in which
;;;923    				case the yield will not cause a context switch unless there
;;;924    				is also a higher priority task in the pending ready list. */
;;;925    				if( xTaskResumeAll() == pdFALSE )
;;;926    				{
;;;927    					portYIELD_WITHIN_API();
;;;928    				}
;;;929    			}
;;;930    			else
;;;931    			{
;;;932    				/* Try again. */
;;;933    				prvUnlockQueue( pxQueue );
;;;934    				( void ) xTaskResumeAll();
;;;935    			}
;;;936    		}
;;;937    		else
;;;938    		{
;;;939    			/* The timeout has expired. */
;;;940    			prvUnlockQueue( pxQueue );
;;;941    			( void ) xTaskResumeAll();
;;;942    
;;;943    			traceQUEUE_SEND_FAILED( pxQueue );
;;;944    			return errQUEUE_FULL;
;;;945    		}
;;;946    	} /*lint -restore */
;;;947    }
000070  b007              ADD      sp,sp,#0x1c
000072  e8bd83f0          POP      {r4-r9,pc}
                  |L16.118|
000076  9805              LDR      r0,[sp,#0x14]         ;872
000078  b918              CBNZ     r0,|L16.130|
00007a  f7fffffe          BL       vPortExitCritical
00007e  2000              MOVS     r0,#0                 ;881
000080  e7f6              B        |L16.112|
                  |L16.130|
000082  f1b90f00          CMP      r9,#0                 ;883
000086  d104              BNE      |L16.146|
000088  a801              ADD      r0,sp,#4              ;887
00008a  f7fffffe          BL       vTaskInternalSetTimeOutState
00008e  f04f0901          MOV      r9,#1                 ;888
                  |L16.146|
000092  f7fffffe          BL       vPortExitCritical
000096  f7fffffe          BL       vTaskSuspendAll
00009a  f7fffffe          BL       vPortEnterCritical
00009e  f9940044          LDRSB    r0,[r4,#0x44]         ;903
0000a2  1c40              ADDS     r0,r0,#1              ;903
0000a4  b910              CBNZ     r0,|L16.172|
0000a6  2000              MOVS     r0,#0                 ;903
0000a8  f8840044          STRB     r0,[r4,#0x44]         ;903
                  |L16.172|
0000ac  f9940045          LDRSB    r0,[r4,#0x45]         ;903
0000b0  1c40              ADDS     r0,r0,#1              ;903
0000b2  b910              CBNZ     r0,|L16.186|
0000b4  2000              MOVS     r0,#0                 ;903
0000b6  f8840045          STRB     r0,[r4,#0x45]         ;903
                  |L16.186|
0000ba  f7fffffe          BL       vPortExitCritical
0000be  a905              ADD      r1,sp,#0x14           ;906
0000c0  a801              ADD      r0,sp,#4              ;906
0000c2  f7fffffe          BL       xTaskCheckForTimeOut
0000c6  b9f0              CBNZ     r0,|L16.262|
0000c8  4620              MOV      r0,r4                 ;908
0000ca  f7fffffe          BL       prvIsQueueFull
0000ce  b1a0              CBZ      r0,|L16.250|
0000d0  f1040010          ADD      r0,r4,#0x10           ;911
0000d4  9905              LDR      r1,[sp,#0x14]         ;911
0000d6  f7fffffe          BL       vTaskPlaceOnEventList
0000da  4620              MOV      r0,r4                 ;918
0000dc  f7fffffe          BL       prvUnlockQueue
0000e0  f7fffffe          BL       xTaskResumeAll
0000e4  2800              CMP      r0,#0                 ;925
0000e6  d195              BNE      |L16.20|
0000e8  f04f5080          MOV      r0,#0x10000000        ;927
0000ec  4909              LDR      r1,|L16.276|
0000ee  6008              STR      r0,[r1,#0]            ;927
0000f0  f3bf8f4f          DSB                            ;927
0000f4  f3bf8f6f          ISB                            ;927
0000f8  e78c              B        |L16.20|
                  |L16.250|
0000fa  4620              MOV      r0,r4                 ;933
0000fc  f7fffffe          BL       prvUnlockQueue
000100  f7fffffe          BL       xTaskResumeAll
000104  e786              B        |L16.20|
                  |L16.262|
000106  4620              MOV      r0,r4                 ;940
000108  f7fffffe          BL       prvUnlockQueue
00010c  f7fffffe          BL       xTaskResumeAll
000110  2000              MOVS     r0,#0                 ;944
000112  e7ad              B        |L16.112|
;;;948    /*-----------------------------------------------------------*/
                          ENDP

                  |L16.276|
                          DCD      0xe000ed04

                          AREA ||i.xQueueGenericSendFromISR||, CODE, READONLY, ALIGN=1

                  xQueueGenericSendFromISR PROC
;;;949    
;;;950    BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;951    {
000004  4605              MOV      r5,r0
000006  468a              MOV      r10,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;952    BaseType_t xReturn;
;;;953    UBaseType_t uxSavedInterruptStatus;
;;;954    Queue_t * const pxQueue = xQueue;
00000c  462c              MOV      r4,r5
;;;955    
;;;956    	configASSERT( pxQueue );
;;;957    	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
;;;958    	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
;;;959    
;;;960    	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;961    	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;962    	above the maximum system call priority are kept permanently enabled, even
;;;963    	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;964    	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;965    	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;966    	failure if a FreeRTOS API function is called from an interrupt that has been
;;;967    	assigned a priority above the configured maximum system call priority.
;;;968    	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;969    	that have been assigned a priority at or (logically) below the maximum
;;;970    	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;971    	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;972    	More information (albeit Cortex-M specific) is provided on the following
;;;973    	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;974    	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;975    
;;;976    	/* Similar to xQueueGenericSend, except without blocking if there is no room
;;;977    	in the queue.  Also don't directly wake a task that was blocked on a queue
;;;978    	read, instead return a flag to say whether a context switch is required or
;;;979    	not (i.e. has a task with a higher priority than us been woken by this
;;;980    	post). */
;;;981    	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
00000e  bf00              NOP      
000010  21bf              MOVS     r1,#0xbf
000012  f3ef8011          MRS      r0,BASEPRI
000016  f3818811          MSR      BASEPRI,r1
00001a  f3bf8f4f          DSB      
00001e  f3bf8f6f          ISB      
000022  bf00              NOP      
000024  4681              MOV      r9,r0
;;;982    	{
;;;983    		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
000026  6ba0              LDR      r0,[r4,#0x38]
000028  6be1              LDR      r1,[r4,#0x3c]
00002a  4288              CMP      r0,r1
00002c  d301              BCC      |L17.50|
00002e  2f02              CMP      r7,#2
000030  d122              BNE      |L17.120|
                  |L17.50|
;;;984    		{
;;;985    			const int8_t cTxLock = pxQueue->cTxLock;
000032  f994b045          LDRSB    r11,[r4,#0x45]
;;;986    			const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
000036  6ba0              LDR      r0,[r4,#0x38]
000038  9000              STR      r0,[sp,#0]
;;;987    
;;;988    			traceQUEUE_SEND_FROM_ISR( pxQueue );
;;;989    
;;;990    			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
;;;991    			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
;;;992    			in a task disinheriting a priority and prvCopyDataToQueue() can be
;;;993    			called here even though the disinherit function does not check if
;;;994    			the scheduler is suspended before accessing the ready lists. */
;;;995    			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
00003a  463a              MOV      r2,r7
00003c  4651              MOV      r1,r10
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       prvCopyDataToQueue
;;;996    
;;;997    			/* The event list is not altered if the queue is locked.  This will
;;;998    			be done when the queue is unlocked later. */
;;;999    			if( cTxLock == queueUNLOCKED )
000044  f10b0001          ADD      r0,r11,#1
000048  b970              CBNZ     r0,|L17.104|
;;;1000   			{
;;;1001   				#if ( configUSE_QUEUE_SETS == 1 )
;;;1002   				{
;;;1003   					if( pxQueue->pxQueueSetContainer != NULL )
;;;1004   					{
;;;1005   						if( ( xCopyPosition == queueOVERWRITE ) && ( uxPreviousMessagesWaiting != ( UBaseType_t ) 0 ) )
;;;1006   						{
;;;1007   							/* Do not notify the queue set as an existing item
;;;1008   							was overwritten in the queue so the number of items
;;;1009   							in the queue has not changed. */
;;;1010   							mtCOVERAGE_TEST_MARKER();
;;;1011   						}
;;;1012   						else if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
;;;1013   						{
;;;1014   							/* The queue is a member of a queue set, and posting
;;;1015   							to the queue set caused a higher priority task to
;;;1016   							unblock.  A context switch is required. */
;;;1017   							if( pxHigherPriorityTaskWoken != NULL )
;;;1018   							{
;;;1019   								*pxHigherPriorityTaskWoken = pdTRUE;
;;;1020   							}
;;;1021   							else
;;;1022   							{
;;;1023   								mtCOVERAGE_TEST_MARKER();
;;;1024   							}
;;;1025   						}
;;;1026   						else
;;;1027   						{
;;;1028   							mtCOVERAGE_TEST_MARKER();
;;;1029   						}
;;;1030   					}
;;;1031   					else
;;;1032   					{
;;;1033   						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;1034   						{
;;;1035   							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;1036   							{
;;;1037   								/* The task waiting has a higher priority so
;;;1038   								record that a context switch is required. */
;;;1039   								if( pxHigherPriorityTaskWoken != NULL )
;;;1040   								{
;;;1041   									*pxHigherPriorityTaskWoken = pdTRUE;
;;;1042   								}
;;;1043   								else
;;;1044   								{
;;;1045   									mtCOVERAGE_TEST_MARKER();
;;;1046   								}
;;;1047   							}
;;;1048   							else
;;;1049   							{
;;;1050   								mtCOVERAGE_TEST_MARKER();
;;;1051   							}
;;;1052   						}
;;;1053   						else
;;;1054   						{
;;;1055   							mtCOVERAGE_TEST_MARKER();
;;;1056   						}
;;;1057   					}
;;;1058   				}
;;;1059   				#else /* configUSE_QUEUE_SETS */
;;;1060   				{
;;;1061   					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
00004a  6a60              LDR      r0,[r4,#0x24]
00004c  b908              CBNZ     r0,|L17.82|
00004e  2001              MOVS     r0,#1
000050  e000              B        |L17.84|
                  |L17.82|
000052  2000              MOVS     r0,#0
                  |L17.84|
000054  b938              CBNZ     r0,|L17.102|
;;;1062   					{
;;;1063   						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
000056  f1040024          ADD      r0,r4,#0x24
00005a  f7fffffe          BL       xTaskRemoveFromEventList
00005e  b110              CBZ      r0,|L17.102|
;;;1064   						{
;;;1065   							/* The task waiting has a higher priority so record that a
;;;1066   							context	switch is required. */
;;;1067   							if( pxHigherPriorityTaskWoken != NULL )
000060  b10e              CBZ      r6,|L17.102|
;;;1068   							{
;;;1069   								*pxHigherPriorityTaskWoken = pdTRUE;
000062  2001              MOVS     r0,#1
000064  6030              STR      r0,[r6,#0]
                  |L17.102|
;;;1070   							}
;;;1071   							else
;;;1072   							{
;;;1073   								mtCOVERAGE_TEST_MARKER();
;;;1074   							}
;;;1075   						}
;;;1076   						else
;;;1077   						{
;;;1078   							mtCOVERAGE_TEST_MARKER();
;;;1079   						}
;;;1080   					}
;;;1081   					else
;;;1082   					{
;;;1083   						mtCOVERAGE_TEST_MARKER();
;;;1084   					}
;;;1085   					
;;;1086   					/* Not used in this path. */
;;;1087   					( void ) uxPreviousMessagesWaiting;
000066  e004              B        |L17.114|
                  |L17.104|
;;;1088   				}
;;;1089   				#endif /* configUSE_QUEUE_SETS */
;;;1090   			}
;;;1091   			else
;;;1092   			{
;;;1093   				/* Increment the lock count so the task that unlocks the queue
;;;1094   				knows that data was posted while it was locked. */
;;;1095   				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
000068  f10b0001          ADD      r0,r11,#1
00006c  b240              SXTB     r0,r0
00006e  f8840045          STRB     r0,[r4,#0x45]
                  |L17.114|
;;;1096   			}
;;;1097   
;;;1098   			xReturn = pdPASS;
000072  f04f0801          MOV      r8,#1
;;;1099   		}
000076  e001              B        |L17.124|
                  |L17.120|
;;;1100   		else
;;;1101   		{
;;;1102   			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
;;;1103   			xReturn = errQUEUE_FULL;
000078  f04f0800          MOV      r8,#0
                  |L17.124|
;;;1104   		}
;;;1105   	}
;;;1106   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
00007c  bf00              NOP      
00007e  f3898811          MSR      BASEPRI,r9
000082  bf00              NOP      
;;;1107   
;;;1108   	return xReturn;
000084  4640              MOV      r0,r8
;;;1109   }
000086  e8bd8ff8          POP      {r3-r11,pc}
;;;1110   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueueGiveFromISR||, CODE, READONLY, ALIGN=1

                  xQueueGiveFromISR PROC
;;;1111   
;;;1112   BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1113   {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
;;;1114   BaseType_t xReturn;
;;;1115   UBaseType_t uxSavedInterruptStatus;
;;;1116   Queue_t * const pxQueue = xQueue;
000008  462c              MOV      r4,r5
;;;1117   
;;;1118   	/* Similar to xQueueGenericSendFromISR() but used with semaphores where the
;;;1119   	item size is 0.  Don't directly wake a task that was blocked on a queue
;;;1120   	read, instead return a flag to say whether a context switch is required or
;;;1121   	not (i.e. has a task with a higher priority than us been woken by this
;;;1122   	post). */
;;;1123   
;;;1124   	configASSERT( pxQueue );
;;;1125   
;;;1126   	/* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()
;;;1127   	if the item size is not 0. */
;;;1128   	configASSERT( pxQueue->uxItemSize == 0 );
;;;1129   
;;;1130   	/* Normally a mutex would not be given from an interrupt, especially if
;;;1131   	there is a mutex holder, as priority inheritance makes no sense for an
;;;1132   	interrupts, only tasks. */
;;;1133   	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->u.xSemaphore.xMutexHolder != NULL ) ) );
;;;1134   
;;;1135   	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;1136   	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;1137   	above the maximum system call priority are kept permanently enabled, even
;;;1138   	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;1139   	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;1140   	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1141   	failure if a FreeRTOS API function is called from an interrupt that has been
;;;1142   	assigned a priority above the configured maximum system call priority.
;;;1143   	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;1144   	that have been assigned a priority at or (logically) below the maximum
;;;1145   	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;1146   	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;1147   	More information (albeit Cortex-M specific) is provided on the following
;;;1148   	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1149   	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;1150   
;;;1151   	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
00000a  bf00              NOP      
00000c  21bf              MOVS     r1,#0xbf
00000e  f3ef8011          MRS      r0,BASEPRI
000012  f3818811          MSR      BASEPRI,r1
000016  f3bf8f4f          DSB      
00001a  f3bf8f6f          ISB      
00001e  bf00              NOP      
000020  4680              MOV      r8,r0
;;;1152   	{
;;;1153   		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
000022  f8d49038          LDR      r9,[r4,#0x38]
;;;1154   
;;;1155   		/* When the queue is used to implement a semaphore no data is ever
;;;1156   		moved through the queue but it is still valid to see if the queue 'has
;;;1157   		space'. */
;;;1158   		if( uxMessagesWaiting < pxQueue->uxLength )
000026  6be0              LDR      r0,[r4,#0x3c]
000028  4548              CMP      r0,r9
00002a  d91d              BLS      |L18.104|
;;;1159   		{
;;;1160   			const int8_t cTxLock = pxQueue->cTxLock;
00002c  f994a045          LDRSB    r10,[r4,#0x45]
;;;1161   
;;;1162   			traceQUEUE_SEND_FROM_ISR( pxQueue );
;;;1163   
;;;1164   			/* A task can only have an inherited priority if it is a mutex
;;;1165   			holder - and if there is a mutex holder then the mutex cannot be
;;;1166   			given from an ISR.  As this is the ISR version of the function it
;;;1167   			can be assumed there is no mutex holder and no need to determine if
;;;1168   			priority disinheritance is needed.  Simply increase the count of
;;;1169   			messages (semaphores) available. */
;;;1170   			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
000030  f1090001          ADD      r0,r9,#1
000034  63a0              STR      r0,[r4,#0x38]
;;;1171   
;;;1172   			/* The event list is not altered if the queue is locked.  This will
;;;1173   			be done when the queue is unlocked later. */
;;;1174   			if( cTxLock == queueUNLOCKED )
000036  f10a0001          ADD      r0,r10,#1
00003a  b970              CBNZ     r0,|L18.90|
;;;1175   			{
;;;1176   				#if ( configUSE_QUEUE_SETS == 1 )
;;;1177   				{
;;;1178   					if( pxQueue->pxQueueSetContainer != NULL )
;;;1179   					{
;;;1180   						if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
;;;1181   						{
;;;1182   							/* The semaphore is a member of a queue set, and
;;;1183   							posting	to the queue set caused a higher priority
;;;1184   							task to	unblock.  A context switch is required. */
;;;1185   							if( pxHigherPriorityTaskWoken != NULL )
;;;1186   							{
;;;1187   								*pxHigherPriorityTaskWoken = pdTRUE;
;;;1188   							}
;;;1189   							else
;;;1190   							{
;;;1191   								mtCOVERAGE_TEST_MARKER();
;;;1192   							}
;;;1193   						}
;;;1194   						else
;;;1195   						{
;;;1196   							mtCOVERAGE_TEST_MARKER();
;;;1197   						}
;;;1198   					}
;;;1199   					else
;;;1200   					{
;;;1201   						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;1202   						{
;;;1203   							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;1204   							{
;;;1205   								/* The task waiting has a higher priority so
;;;1206   								record that a context switch is required. */
;;;1207   								if( pxHigherPriorityTaskWoken != NULL )
;;;1208   								{
;;;1209   									*pxHigherPriorityTaskWoken = pdTRUE;
;;;1210   								}
;;;1211   								else
;;;1212   								{
;;;1213   									mtCOVERAGE_TEST_MARKER();
;;;1214   								}
;;;1215   							}
;;;1216   							else
;;;1217   							{
;;;1218   								mtCOVERAGE_TEST_MARKER();
;;;1219   							}
;;;1220   						}
;;;1221   						else
;;;1222   						{
;;;1223   							mtCOVERAGE_TEST_MARKER();
;;;1224   						}
;;;1225   					}
;;;1226   				}
;;;1227   				#else /* configUSE_QUEUE_SETS */
;;;1228   				{
;;;1229   					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
00003c  6a60              LDR      r0,[r4,#0x24]
00003e  b908              CBNZ     r0,|L18.68|
000040  2001              MOVS     r0,#1
000042  e000              B        |L18.70|
                  |L18.68|
000044  2000              MOVS     r0,#0
                  |L18.70|
000046  b968              CBNZ     r0,|L18.100|
;;;1230   					{
;;;1231   						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
000048  f1040024          ADD      r0,r4,#0x24
00004c  f7fffffe          BL       xTaskRemoveFromEventList
000050  b140              CBZ      r0,|L18.100|
;;;1232   						{
;;;1233   							/* The task waiting has a higher priority so record that a
;;;1234   							context	switch is required. */
;;;1235   							if( pxHigherPriorityTaskWoken != NULL )
000052  b13e              CBZ      r6,|L18.100|
;;;1236   							{
;;;1237   								*pxHigherPriorityTaskWoken = pdTRUE;
000054  2001              MOVS     r0,#1
000056  6030              STR      r0,[r6,#0]
000058  e004              B        |L18.100|
                  |L18.90|
;;;1238   							}
;;;1239   							else
;;;1240   							{
;;;1241   								mtCOVERAGE_TEST_MARKER();
;;;1242   							}
;;;1243   						}
;;;1244   						else
;;;1245   						{
;;;1246   							mtCOVERAGE_TEST_MARKER();
;;;1247   						}
;;;1248   					}
;;;1249   					else
;;;1250   					{
;;;1251   						mtCOVERAGE_TEST_MARKER();
;;;1252   					}
;;;1253   				}
;;;1254   				#endif /* configUSE_QUEUE_SETS */
;;;1255   			}
;;;1256   			else
;;;1257   			{
;;;1258   				/* Increment the lock count so the task that unlocks the queue
;;;1259   				knows that data was posted while it was locked. */
;;;1260   				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
00005a  f10a0001          ADD      r0,r10,#1
00005e  b240              SXTB     r0,r0
000060  f8840045          STRB     r0,[r4,#0x45]
                  |L18.100|
;;;1261   			}
;;;1262   
;;;1263   			xReturn = pdPASS;
000064  2701              MOVS     r7,#1
;;;1264   		}
000066  e000              B        |L18.106|
                  |L18.104|
;;;1265   		else
;;;1266   		{
;;;1267   			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
;;;1268   			xReturn = errQUEUE_FULL;
000068  2700              MOVS     r7,#0
                  |L18.106|
;;;1269   		}
;;;1270   	}
;;;1271   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
00006a  bf00              NOP      
00006c  f3888811          MSR      BASEPRI,r8
000070  bf00              NOP      
;;;1272   
;;;1273   	return xReturn;
000072  4638              MOV      r0,r7
;;;1274   }
000074  e8bd87f0          POP      {r4-r10,pc}
;;;1275   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueueIsQueueEmptyFromISR||, CODE, READONLY, ALIGN=1

                  xQueueIsQueueEmptyFromISR PROC
;;;2311   
;;;2312   BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
000000  4601              MOV      r1,r0
;;;2313   {
;;;2314   BaseType_t xReturn;
;;;2315   Queue_t * const pxQueue = xQueue;
000002  460a              MOV      r2,r1
;;;2316   
;;;2317   	configASSERT( pxQueue );
;;;2318   	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
000004  6b93              LDR      r3,[r2,#0x38]
000006  b90b              CBNZ     r3,|L19.12|
;;;2319   	{
;;;2320   		xReturn = pdTRUE;
000008  2001              MOVS     r0,#1
00000a  e000              B        |L19.14|
                  |L19.12|
;;;2321   	}
;;;2322   	else
;;;2323   	{
;;;2324   		xReturn = pdFALSE;
00000c  2000              MOVS     r0,#0
                  |L19.14|
;;;2325   	}
;;;2326   
;;;2327   	return xReturn;
;;;2328   } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
00000e  4770              BX       lr
;;;2329   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueueIsQueueFullFromISR||, CODE, READONLY, ALIGN=1

                  xQueueIsQueueFullFromISR PROC
;;;2351   
;;;2352   BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
000000  b510              PUSH     {r4,lr}
;;;2353   {
000002  4601              MOV      r1,r0
;;;2354   BaseType_t xReturn;
;;;2355   Queue_t * const pxQueue = xQueue;
000004  460a              MOV      r2,r1
;;;2356   
;;;2357   	configASSERT( pxQueue );
;;;2358   	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
000006  6b93              LDR      r3,[r2,#0x38]
000008  6bd4              LDR      r4,[r2,#0x3c]
00000a  42a3              CMP      r3,r4
00000c  d101              BNE      |L20.18|
;;;2359   	{
;;;2360   		xReturn = pdTRUE;
00000e  2001              MOVS     r0,#1
000010  e000              B        |L20.20|
                  |L20.18|
;;;2361   	}
;;;2362   	else
;;;2363   	{
;;;2364   		xReturn = pdFALSE;
000012  2000              MOVS     r0,#0
                  |L20.20|
;;;2365   	}
;;;2366   
;;;2367   	return xReturn;
;;;2368   } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
000014  bd10              POP      {r4,pc}
;;;2369   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueuePeek||, CODE, READONLY, ALIGN=2

                  xQueuePeek PROC
;;;1635   
;;;1636   BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
000000  e92d43f7          PUSH     {r0-r2,r4-r9,lr}
;;;1637   {
000004  b082              SUB      sp,sp,#8
000006  4605              MOV      r5,r0
000008  460f              MOV      r7,r1
;;;1638   BaseType_t xEntryTimeSet = pdFALSE;
00000a  f04f0800          MOV      r8,#0
;;;1639   TimeOut_t xTimeOut;
;;;1640   int8_t *pcOriginalReadPosition;
;;;1641   Queue_t * const pxQueue = xQueue;
00000e  462c              MOV      r4,r5
;;;1642   
;;;1643   	/* Check the pointer is not NULL. */
;;;1644   	configASSERT( ( pxQueue ) );
;;;1645   
;;;1646   	/* The buffer into which data is received can only be NULL if the data size
;;;1647   	is zero (so no data is copied into the buffer. */
;;;1648   	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
;;;1649   
;;;1650   	/* Cannot block if the scheduler is suspended. */
;;;1651   	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
;;;1652   	{
;;;1653   		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
;;;1654   	}
;;;1655   	#endif
;;;1656   
;;;1657   
;;;1658   	/*lint -save -e904  This function relaxes the coding standard somewhat to
;;;1659   	allow return statements within the function itself.  This is done in the
;;;1660   	interest of execution time efficiency. */
;;;1661   	for( ;; )
000010  bf00              NOP      
                  |L21.18|
;;;1662   	{
;;;1663   		taskENTER_CRITICAL();
000012  f7fffffe          BL       vPortEnterCritical
;;;1664   		{
;;;1665   			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
000016  f8d49038          LDR      r9,[r4,#0x38]
;;;1666   
;;;1667   			/* Is there data in the queue now?  To be running the calling task
;;;1668   			must be the highest priority task wanting to access the queue. */
;;;1669   			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
00001a  f1b90f00          CMP      r9,#0
00001e  d01e              BEQ      |L21.94|
;;;1670   			{
;;;1671   				/* Remember the read position so it can be reset after the data
;;;1672   				is read from the queue as this function is only peeking the
;;;1673   				data, not removing it. */
;;;1674   				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
000020  68e6              LDR      r6,[r4,#0xc]
;;;1675   
;;;1676   				prvCopyDataFromQueue( pxQueue, pvBuffer );
000022  4639              MOV      r1,r7
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       prvCopyDataFromQueue
;;;1677   				traceQUEUE_PEEK( pxQueue );
;;;1678   
;;;1679   				/* The data is not being removed, so reset the read pointer. */
;;;1680   				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
00002a  60e6              STR      r6,[r4,#0xc]
;;;1681   
;;;1682   				/* The data is being left in the queue, so see if there are
;;;1683   				any other tasks waiting for the data. */
;;;1684   				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
00002c  6a60              LDR      r0,[r4,#0x24]
00002e  b908              CBNZ     r0,|L21.52|
000030  2001              MOVS     r0,#1
000032  e000              B        |L21.54|
                  |L21.52|
000034  2000              MOVS     r0,#0
                  |L21.54|
000036  b960              CBNZ     r0,|L21.82|
;;;1685   				{
;;;1686   					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
000038  f1040024          ADD      r0,r4,#0x24
00003c  f7fffffe          BL       xTaskRemoveFromEventList
000040  b138              CBZ      r0,|L21.82|
;;;1687   					{
;;;1688   						/* The task waiting has a higher priority than this task. */
;;;1689   						queueYIELD_IF_USING_PREEMPTION();
000042  f04f5080          MOV      r0,#0x10000000
000046  4930              LDR      r1,|L21.264|
000048  6008              STR      r0,[r1,#0]
00004a  f3bf8f4f          DSB      
00004e  f3bf8f6f          ISB      
                  |L21.82|
;;;1690   					}
;;;1691   					else
;;;1692   					{
;;;1693   						mtCOVERAGE_TEST_MARKER();
;;;1694   					}
;;;1695   				}
;;;1696   				else
;;;1697   				{
;;;1698   					mtCOVERAGE_TEST_MARKER();
;;;1699   				}
;;;1700   
;;;1701   				taskEXIT_CRITICAL();
000052  f7fffffe          BL       vPortExitCritical
;;;1702   				return pdPASS;
000056  2001              MOVS     r0,#1
                  |L21.88|
;;;1703   			}
;;;1704   			else
;;;1705   			{
;;;1706   				if( xTicksToWait == ( TickType_t ) 0 )
;;;1707   				{
;;;1708   					/* The queue was empty and no block time is specified (or
;;;1709   					the block time has expired) so leave now. */
;;;1710   					taskEXIT_CRITICAL();
;;;1711   					traceQUEUE_PEEK_FAILED( pxQueue );
;;;1712   					return errQUEUE_EMPTY;
;;;1713   				}
;;;1714   				else if( xEntryTimeSet == pdFALSE )
;;;1715   				{
;;;1716   					/* The queue was empty and a block time was specified so
;;;1717   					configure the timeout structure ready to enter the blocked
;;;1718   					state. */
;;;1719   					vTaskInternalSetTimeOutState( &xTimeOut );
;;;1720   					xEntryTimeSet = pdTRUE;
;;;1721   				}
;;;1722   				else
;;;1723   				{
;;;1724   					/* Entry time was already set. */
;;;1725   					mtCOVERAGE_TEST_MARKER();
;;;1726   				}
;;;1727   			}
;;;1728   		}
;;;1729   		taskEXIT_CRITICAL();
;;;1730   
;;;1731   		/* Interrupts and other tasks can send to and receive from the queue
;;;1732   		now the critical section has been exited. */
;;;1733   
;;;1734   		vTaskSuspendAll();
;;;1735   		prvLockQueue( pxQueue );
;;;1736   
;;;1737   		/* Update the timeout state to see if it has expired yet. */
;;;1738   		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
;;;1739   		{
;;;1740   			/* Timeout has not expired yet, check to see if there is data in the
;;;1741   			queue now, and if not enter the Blocked state to wait for data. */
;;;1742   			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
;;;1743   			{
;;;1744   				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
;;;1745   				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
;;;1746   				prvUnlockQueue( pxQueue );
;;;1747   				if( xTaskResumeAll() == pdFALSE )
;;;1748   				{
;;;1749   					portYIELD_WITHIN_API();
;;;1750   				}
;;;1751   				else
;;;1752   				{
;;;1753   					mtCOVERAGE_TEST_MARKER();
;;;1754   				}
;;;1755   			}
;;;1756   			else
;;;1757   			{
;;;1758   				/* There is data in the queue now, so don't enter the blocked
;;;1759   				state, instead return to try and obtain the data. */
;;;1760   				prvUnlockQueue( pxQueue );
;;;1761   				( void ) xTaskResumeAll();
;;;1762   			}
;;;1763   		}
;;;1764   		else
;;;1765   		{
;;;1766   			/* The timeout has expired.  If there is still no data in the queue
;;;1767   			exit, otherwise go back and try to read the data again. */
;;;1768   			prvUnlockQueue( pxQueue );
;;;1769   			( void ) xTaskResumeAll();
;;;1770   
;;;1771   			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
;;;1772   			{
;;;1773   				traceQUEUE_PEEK_FAILED( pxQueue );
;;;1774   				return errQUEUE_EMPTY;
;;;1775   			}
;;;1776   			else
;;;1777   			{
;;;1778   				mtCOVERAGE_TEST_MARKER();
;;;1779   			}
;;;1780   		}
;;;1781   	} /*lint -restore */
;;;1782   }
000058  b005              ADD      sp,sp,#0x14
00005a  e8bd83f0          POP      {r4-r9,pc}
                  |L21.94|
00005e  9804              LDR      r0,[sp,#0x10]         ;1706
000060  b918              CBNZ     r0,|L21.106|
000062  f7fffffe          BL       vPortExitCritical
000066  2000              MOVS     r0,#0                 ;1712
000068  e7f6              B        |L21.88|
                  |L21.106|
00006a  f1b80f00          CMP      r8,#0                 ;1714
00006e  d104              BNE      |L21.122|
000070  4668              MOV      r0,sp                 ;1719
000072  f7fffffe          BL       vTaskInternalSetTimeOutState
000076  f04f0801          MOV      r8,#1                 ;1720
                  |L21.122|
00007a  f7fffffe          BL       vPortExitCritical
00007e  f7fffffe          BL       vTaskSuspendAll
000082  f7fffffe          BL       vPortEnterCritical
000086  f9940044          LDRSB    r0,[r4,#0x44]         ;1735
00008a  1c40              ADDS     r0,r0,#1              ;1735
00008c  b910              CBNZ     r0,|L21.148|
00008e  2000              MOVS     r0,#0                 ;1735
000090  f8840044          STRB     r0,[r4,#0x44]         ;1735
                  |L21.148|
000094  f9940045          LDRSB    r0,[r4,#0x45]         ;1735
000098  1c40              ADDS     r0,r0,#1              ;1735
00009a  b910              CBNZ     r0,|L21.162|
00009c  2000              MOVS     r0,#0                 ;1735
00009e  f8840045          STRB     r0,[r4,#0x45]         ;1735
                  |L21.162|
0000a2  f7fffffe          BL       vPortExitCritical
0000a6  a904              ADD      r1,sp,#0x10           ;1738
0000a8  4668              MOV      r0,sp                 ;1738
0000aa  f7fffffe          BL       xTaskCheckForTimeOut
0000ae  b9f0              CBNZ     r0,|L21.238|
0000b0  4620              MOV      r0,r4                 ;1742
0000b2  f7fffffe          BL       prvIsQueueEmpty
0000b6  b1a0              CBZ      r0,|L21.226|
0000b8  f1040024          ADD      r0,r4,#0x24           ;1745
0000bc  9904              LDR      r1,[sp,#0x10]         ;1745
0000be  f7fffffe          BL       vTaskPlaceOnEventList
0000c2  4620              MOV      r0,r4                 ;1746
0000c4  f7fffffe          BL       prvUnlockQueue
0000c8  f7fffffe          BL       xTaskResumeAll
0000cc  2800              CMP      r0,#0                 ;1747
0000ce  d1a0              BNE      |L21.18|
0000d0  f04f5080          MOV      r0,#0x10000000        ;1749
0000d4  490c              LDR      r1,|L21.264|
0000d6  6008              STR      r0,[r1,#0]            ;1749
0000d8  f3bf8f4f          DSB                            ;1749
0000dc  f3bf8f6f          ISB                            ;1749
0000e0  e797              B        |L21.18|
                  |L21.226|
0000e2  4620              MOV      r0,r4                 ;1760
0000e4  f7fffffe          BL       prvUnlockQueue
0000e8  f7fffffe          BL       xTaskResumeAll
0000ec  e791              B        |L21.18|
                  |L21.238|
0000ee  4620              MOV      r0,r4                 ;1768
0000f0  f7fffffe          BL       prvUnlockQueue
0000f4  f7fffffe          BL       xTaskResumeAll
0000f8  4620              MOV      r0,r4                 ;1771
0000fa  f7fffffe          BL       prvIsQueueEmpty
0000fe  2800              CMP      r0,#0                 ;1771
000100  d087              BEQ      |L21.18|
000102  2000              MOVS     r0,#0                 ;1774
000104  e7a8              B        |L21.88|
;;;1783   /*-----------------------------------------------------------*/
                          ENDP

000106  0000              DCW      0x0000
                  |L21.264|
                          DCD      0xe000ed04

                          AREA ||i.xQueuePeekFromISR||, CODE, READONLY, ALIGN=1

                  xQueuePeekFromISR PROC
;;;1875   
;;;1876   BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1877   {
000004  4605              MOV      r5,r0
000006  4689              MOV      r9,r1
;;;1878   BaseType_t xReturn;
;;;1879   UBaseType_t uxSavedInterruptStatus;
;;;1880   int8_t *pcOriginalReadPosition;
;;;1881   Queue_t * const pxQueue = xQueue;
000008  462c              MOV      r4,r5
;;;1882   
;;;1883   	configASSERT( pxQueue );
;;;1884   	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
;;;1885   	configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
;;;1886   
;;;1887   	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;1888   	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;1889   	above the maximum system call priority are kept permanently enabled, even
;;;1890   	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;1891   	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;1892   	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1893   	failure if a FreeRTOS API function is called from an interrupt that has been
;;;1894   	assigned a priority above the configured maximum system call priority.
;;;1895   	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;1896   	that have been assigned a priority at or (logically) below the maximum
;;;1897   	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;1898   	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;1899   	More information (albeit Cortex-M specific) is provided on the following
;;;1900   	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1901   	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;1902   
;;;1903   	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
00000a  bf00              NOP      
00000c  21bf              MOVS     r1,#0xbf
00000e  f3ef8011          MRS      r0,BASEPRI
000012  f3818811          MSR      BASEPRI,r1
000016  f3bf8f4f          DSB      
00001a  f3bf8f6f          ISB      
00001e  bf00              NOP      
000020  4607              MOV      r7,r0
;;;1904   	{
;;;1905   		/* Cannot block in an ISR, so check there is data available. */
;;;1906   		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
000022  6ba0              LDR      r0,[r4,#0x38]
000024  b148              CBZ      r0,|L22.58|
;;;1907   		{
;;;1908   			traceQUEUE_PEEK_FROM_ISR( pxQueue );
;;;1909   
;;;1910   			/* Remember the read position so it can be reset as nothing is
;;;1911   			actually being removed from the queue. */
;;;1912   			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
000026  f8d4800c          LDR      r8,[r4,#0xc]
;;;1913   			prvCopyDataFromQueue( pxQueue, pvBuffer );
00002a  4649              MOV      r1,r9
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       prvCopyDataFromQueue
;;;1914   			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
000032  f8c4800c          STR      r8,[r4,#0xc]
;;;1915   
;;;1916   			xReturn = pdPASS;
000036  2601              MOVS     r6,#1
000038  e000              B        |L22.60|
                  |L22.58|
;;;1917   		}
;;;1918   		else
;;;1919   		{
;;;1920   			xReturn = pdFAIL;
00003a  2600              MOVS     r6,#0
                  |L22.60|
;;;1921   			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
;;;1922   		}
;;;1923   	}
;;;1924   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
00003c  bf00              NOP      
00003e  f3878811          MSR      BASEPRI,r7
000042  bf00              NOP      
;;;1925   
;;;1926   	return xReturn;
000044  4630              MOV      r0,r6
;;;1927   }
000046  e8bd87f0          POP      {r4-r10,pc}
;;;1928   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueueReceive||, CODE, READONLY, ALIGN=2

                  xQueueReceive PROC
;;;1276   
;;;1277   BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
000000  e92d41f7          PUSH     {r0-r2,r4-r8,lr}
;;;1278   {
000004  b083              SUB      sp,sp,#0xc
000006  4605              MOV      r5,r0
000008  460f              MOV      r7,r1
;;;1279   BaseType_t xEntryTimeSet = pdFALSE;
00000a  f04f0800          MOV      r8,#0
;;;1280   TimeOut_t xTimeOut;
;;;1281   Queue_t * const pxQueue = xQueue;
00000e  462c              MOV      r4,r5
;;;1282   
;;;1283   	/* Check the pointer is not NULL. */
;;;1284   	configASSERT( ( pxQueue ) );
;;;1285   
;;;1286   	/* The buffer into which data is received can only be NULL if the data size
;;;1287   	is zero (so no data is copied into the buffer. */
;;;1288   	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
;;;1289   
;;;1290   	/* Cannot block if the scheduler is suspended. */
;;;1291   	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
;;;1292   	{
;;;1293   		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
;;;1294   	}
;;;1295   	#endif
;;;1296   
;;;1297   
;;;1298   	/*lint -save -e904  This function relaxes the coding standard somewhat to
;;;1299   	allow return statements within the function itself.  This is done in the
;;;1300   	interest of execution time efficiency. */
;;;1301   	for( ;; )
000010  bf00              NOP      
                  |L23.18|
;;;1302   	{
;;;1303   		taskENTER_CRITICAL();
000012  f7fffffe          BL       vPortEnterCritical
;;;1304   		{
;;;1305   			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
000016  6ba6              LDR      r6,[r4,#0x38]
;;;1306   
;;;1307   			/* Is there data in the queue now?  To be running the calling task
;;;1308   			must be the highest priority task wanting to access the queue. */
;;;1309   			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
000018  b1f6              CBZ      r6,|L23.88|
;;;1310   			{
;;;1311   				/* Data available, remove one item. */
;;;1312   				prvCopyDataFromQueue( pxQueue, pvBuffer );
00001a  4639              MOV      r1,r7
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       prvCopyDataFromQueue
;;;1313   				traceQUEUE_RECEIVE( pxQueue );
;;;1314   				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
000022  1e70              SUBS     r0,r6,#1
000024  63a0              STR      r0,[r4,#0x38]
;;;1315   
;;;1316   				/* There is now space in the queue, were any tasks waiting to
;;;1317   				post to the queue?  If so, unblock the highest priority waiting
;;;1318   				task. */
;;;1319   				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
000026  6920              LDR      r0,[r4,#0x10]
000028  b908              CBNZ     r0,|L23.46|
00002a  2001              MOVS     r0,#1
00002c  e000              B        |L23.48|
                  |L23.46|
00002e  2000              MOVS     r0,#0
                  |L23.48|
000030  b960              CBNZ     r0,|L23.76|
;;;1320   				{
;;;1321   					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
000032  f1040010          ADD      r0,r4,#0x10
000036  f7fffffe          BL       xTaskRemoveFromEventList
00003a  b138              CBZ      r0,|L23.76|
;;;1322   					{
;;;1323   						queueYIELD_IF_USING_PREEMPTION();
00003c  f04f5080          MOV      r0,#0x10000000
000040  492f              LDR      r1,|L23.256|
000042  6008              STR      r0,[r1,#0]
000044  f3bf8f4f          DSB      
000048  f3bf8f6f          ISB      
                  |L23.76|
;;;1324   					}
;;;1325   					else
;;;1326   					{
;;;1327   						mtCOVERAGE_TEST_MARKER();
;;;1328   					}
;;;1329   				}
;;;1330   				else
;;;1331   				{
;;;1332   					mtCOVERAGE_TEST_MARKER();
;;;1333   				}
;;;1334   
;;;1335   				taskEXIT_CRITICAL();
00004c  f7fffffe          BL       vPortExitCritical
;;;1336   				return pdPASS;
000050  2001              MOVS     r0,#1
                  |L23.82|
;;;1337   			}
;;;1338   			else
;;;1339   			{
;;;1340   				if( xTicksToWait == ( TickType_t ) 0 )
;;;1341   				{
;;;1342   					/* The queue was empty and no block time is specified (or
;;;1343   					the block time has expired) so leave now. */
;;;1344   					taskEXIT_CRITICAL();
;;;1345   					traceQUEUE_RECEIVE_FAILED( pxQueue );
;;;1346   					return errQUEUE_EMPTY;
;;;1347   				}
;;;1348   				else if( xEntryTimeSet == pdFALSE )
;;;1349   				{
;;;1350   					/* The queue was empty and a block time was specified so
;;;1351   					configure the timeout structure. */
;;;1352   					vTaskInternalSetTimeOutState( &xTimeOut );
;;;1353   					xEntryTimeSet = pdTRUE;
;;;1354   				}
;;;1355   				else
;;;1356   				{
;;;1357   					/* Entry time was already set. */
;;;1358   					mtCOVERAGE_TEST_MARKER();
;;;1359   				}
;;;1360   			}
;;;1361   		}
;;;1362   		taskEXIT_CRITICAL();
;;;1363   
;;;1364   		/* Interrupts and other tasks can send to and receive from the queue
;;;1365   		now the critical section has been exited. */
;;;1366   
;;;1367   		vTaskSuspendAll();
;;;1368   		prvLockQueue( pxQueue );
;;;1369   
;;;1370   		/* Update the timeout state to see if it has expired yet. */
;;;1371   		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
;;;1372   		{
;;;1373   			/* The timeout has not expired.  If the queue is still empty place
;;;1374   			the task on the list of tasks waiting to receive from the queue. */
;;;1375   			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
;;;1376   			{
;;;1377   				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
;;;1378   				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
;;;1379   				prvUnlockQueue( pxQueue );
;;;1380   				if( xTaskResumeAll() == pdFALSE )
;;;1381   				{
;;;1382   					portYIELD_WITHIN_API();
;;;1383   				}
;;;1384   				else
;;;1385   				{
;;;1386   					mtCOVERAGE_TEST_MARKER();
;;;1387   				}
;;;1388   			}
;;;1389   			else
;;;1390   			{
;;;1391   				/* The queue contains data again.  Loop back to try and read the
;;;1392   				data. */
;;;1393   				prvUnlockQueue( pxQueue );
;;;1394   				( void ) xTaskResumeAll();
;;;1395   			}
;;;1396   		}
;;;1397   		else
;;;1398   		{
;;;1399   			/* Timed out.  If there is no data in the queue exit, otherwise loop
;;;1400   			back and attempt to read the data. */
;;;1401   			prvUnlockQueue( pxQueue );
;;;1402   			( void ) xTaskResumeAll();
;;;1403   
;;;1404   			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
;;;1405   			{
;;;1406   				traceQUEUE_RECEIVE_FAILED( pxQueue );
;;;1407   				return errQUEUE_EMPTY;
;;;1408   			}
;;;1409   			else
;;;1410   			{
;;;1411   				mtCOVERAGE_TEST_MARKER();
;;;1412   			}
;;;1413   		}
;;;1414   	} /*lint -restore */
;;;1415   }
000052  b006              ADD      sp,sp,#0x18
000054  e8bd81f0          POP      {r4-r8,pc}
                  |L23.88|
000058  9805              LDR      r0,[sp,#0x14]         ;1340
00005a  b918              CBNZ     r0,|L23.100|
00005c  f7fffffe          BL       vPortExitCritical
000060  2000              MOVS     r0,#0                 ;1346
000062  e7f6              B        |L23.82|
                  |L23.100|
000064  f1b80f00          CMP      r8,#0                 ;1348
000068  d104              BNE      |L23.116|
00006a  a801              ADD      r0,sp,#4              ;1352
00006c  f7fffffe          BL       vTaskInternalSetTimeOutState
000070  f04f0801          MOV      r8,#1                 ;1353
                  |L23.116|
000074  f7fffffe          BL       vPortExitCritical
000078  f7fffffe          BL       vTaskSuspendAll
00007c  f7fffffe          BL       vPortEnterCritical
000080  f9940044          LDRSB    r0,[r4,#0x44]         ;1368
000084  1c40              ADDS     r0,r0,#1              ;1368
000086  b910              CBNZ     r0,|L23.142|
000088  2000              MOVS     r0,#0                 ;1368
00008a  f8840044          STRB     r0,[r4,#0x44]         ;1368
                  |L23.142|
00008e  f9940045          LDRSB    r0,[r4,#0x45]         ;1368
000092  1c40              ADDS     r0,r0,#1              ;1368
000094  b910              CBNZ     r0,|L23.156|
000096  2000              MOVS     r0,#0                 ;1368
000098  f8840045          STRB     r0,[r4,#0x45]         ;1368
                  |L23.156|
00009c  f7fffffe          BL       vPortExitCritical
0000a0  a905              ADD      r1,sp,#0x14           ;1371
0000a2  a801              ADD      r0,sp,#4              ;1371
0000a4  f7fffffe          BL       xTaskCheckForTimeOut
0000a8  b9f0              CBNZ     r0,|L23.232|
0000aa  4620              MOV      r0,r4                 ;1375
0000ac  f7fffffe          BL       prvIsQueueEmpty
0000b0  b1a0              CBZ      r0,|L23.220|
0000b2  f1040024          ADD      r0,r4,#0x24           ;1378
0000b6  9905              LDR      r1,[sp,#0x14]         ;1378
0000b8  f7fffffe          BL       vTaskPlaceOnEventList
0000bc  4620              MOV      r0,r4                 ;1379
0000be  f7fffffe          BL       prvUnlockQueue
0000c2  f7fffffe          BL       xTaskResumeAll
0000c6  2800              CMP      r0,#0                 ;1380
0000c8  d1a3              BNE      |L23.18|
0000ca  f04f5080          MOV      r0,#0x10000000        ;1382
0000ce  490c              LDR      r1,|L23.256|
0000d0  6008              STR      r0,[r1,#0]            ;1382
0000d2  f3bf8f4f          DSB                            ;1382
0000d6  f3bf8f6f          ISB                            ;1382
0000da  e79a              B        |L23.18|
                  |L23.220|
0000dc  4620              MOV      r0,r4                 ;1393
0000de  f7fffffe          BL       prvUnlockQueue
0000e2  f7fffffe          BL       xTaskResumeAll
0000e6  e794              B        |L23.18|
                  |L23.232|
0000e8  4620              MOV      r0,r4                 ;1401
0000ea  f7fffffe          BL       prvUnlockQueue
0000ee  f7fffffe          BL       xTaskResumeAll
0000f2  4620              MOV      r0,r4                 ;1404
0000f4  f7fffffe          BL       prvIsQueueEmpty
0000f8  2800              CMP      r0,#0                 ;1404
0000fa  d08a              BEQ      |L23.18|
0000fc  2000              MOVS     r0,#0                 ;1407
0000fe  e7a8              B        |L23.82|
;;;1416   /*-----------------------------------------------------------*/
                          ENDP

                  |L23.256|
                          DCD      0xe000ed04

                          AREA ||i.xQueueReceiveFromISR||, CODE, READONLY, ALIGN=1

                  xQueueReceiveFromISR PROC
;;;1784   
;;;1785   BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;1786   {
000004  4605              MOV      r5,r0
000006  468a              MOV      r10,r1
000008  4616              MOV      r6,r2
;;;1787   BaseType_t xReturn;
;;;1788   UBaseType_t uxSavedInterruptStatus;
;;;1789   Queue_t * const pxQueue = xQueue;
00000a  462c              MOV      r4,r5
;;;1790   
;;;1791   	configASSERT( pxQueue );
;;;1792   	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
;;;1793   
;;;1794   	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;1795   	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;1796   	above the maximum system call priority are kept permanently enabled, even
;;;1797   	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;1798   	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;1799   	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1800   	failure if a FreeRTOS API function is called from an interrupt that has been
;;;1801   	assigned a priority above the configured maximum system call priority.
;;;1802   	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;1803   	that have been assigned a priority at or (logically) below the maximum
;;;1804   	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;1805   	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;1806   	More information (albeit Cortex-M specific) is provided on the following
;;;1807   	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1808   	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;1809   
;;;1810   	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
00000c  bf00              NOP      
00000e  21bf              MOVS     r1,#0xbf
000010  f3ef8011          MRS      r0,BASEPRI
000014  f3818811          MSR      BASEPRI,r1
000018  f3bf8f4f          DSB      
00001c  f3bf8f6f          ISB      
000020  bf00              NOP      
000022  4680              MOV      r8,r0
;;;1811   	{
;;;1812   		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
000024  f8d49038          LDR      r9,[r4,#0x38]
;;;1813   
;;;1814   		/* Cannot block in an ISR, so check there is data available. */
;;;1815   		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
000028  f1b90f00          CMP      r9,#0
00002c  d021              BEQ      |L24.114|
;;;1816   		{
;;;1817   			const int8_t cRxLock = pxQueue->cRxLock;
00002e  f994b044          LDRSB    r11,[r4,#0x44]
;;;1818   
;;;1819   			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
;;;1820   
;;;1821   			prvCopyDataFromQueue( pxQueue, pvBuffer );
000032  4651              MOV      r1,r10
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       prvCopyDataFromQueue
;;;1822   			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
00003a  f1a90001          SUB      r0,r9,#1
00003e  63a0              STR      r0,[r4,#0x38]
;;;1823   
;;;1824   			/* If the queue is locked the event list will not be modified.
;;;1825   			Instead update the lock count so the task that unlocks the queue
;;;1826   			will know that an ISR has removed data while the queue was
;;;1827   			locked. */
;;;1828   			if( cRxLock == queueUNLOCKED )
000040  f10b0001          ADD      r0,r11,#1
000044  b970              CBNZ     r0,|L24.100|
;;;1829   			{
;;;1830   				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
000046  6920              LDR      r0,[r4,#0x10]
000048  b908              CBNZ     r0,|L24.78|
00004a  2001              MOVS     r0,#1
00004c  e000              B        |L24.80|
                  |L24.78|
00004e  2000              MOVS     r0,#0
                  |L24.80|
000050  b968              CBNZ     r0,|L24.110|
;;;1831   				{
;;;1832   					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
000052  f1040010          ADD      r0,r4,#0x10
000056  f7fffffe          BL       xTaskRemoveFromEventList
00005a  b140              CBZ      r0,|L24.110|
;;;1833   					{
;;;1834   						/* The task waiting has a higher priority than us so
;;;1835   						force a context switch. */
;;;1836   						if( pxHigherPriorityTaskWoken != NULL )
00005c  b13e              CBZ      r6,|L24.110|
;;;1837   						{
;;;1838   							*pxHigherPriorityTaskWoken = pdTRUE;
00005e  2001              MOVS     r0,#1
000060  6030              STR      r0,[r6,#0]
000062  e004              B        |L24.110|
                  |L24.100|
;;;1839   						}
;;;1840   						else
;;;1841   						{
;;;1842   							mtCOVERAGE_TEST_MARKER();
;;;1843   						}
;;;1844   					}
;;;1845   					else
;;;1846   					{
;;;1847   						mtCOVERAGE_TEST_MARKER();
;;;1848   					}
;;;1849   				}
;;;1850   				else
;;;1851   				{
;;;1852   					mtCOVERAGE_TEST_MARKER();
;;;1853   				}
;;;1854   			}
;;;1855   			else
;;;1856   			{
;;;1857   				/* Increment the lock count so the task that unlocks the queue
;;;1858   				knows that data was removed while it was locked. */
;;;1859   				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
000064  f10b0001          ADD      r0,r11,#1
000068  b240              SXTB     r0,r0
00006a  f8840044          STRB     r0,[r4,#0x44]
                  |L24.110|
;;;1860   			}
;;;1861   
;;;1862   			xReturn = pdPASS;
00006e  2701              MOVS     r7,#1
;;;1863   		}
000070  e000              B        |L24.116|
                  |L24.114|
;;;1864   		else
;;;1865   		{
;;;1866   			xReturn = pdFAIL;
000072  2700              MOVS     r7,#0
                  |L24.116|
;;;1867   			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
;;;1868   		}
;;;1869   	}
;;;1870   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
000074  bf00              NOP      
000076  f3888811          MSR      BASEPRI,r8
00007a  bf00              NOP      
;;;1871   
;;;1872   	return xReturn;
00007c  4638              MOV      r0,r7
;;;1873   }
00007e  e8bd9ff0          POP      {r4-r12,pc}
;;;1874   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueueSemaphoreTake||, CODE, READONLY, ALIGN=2

                  xQueueSemaphoreTake PROC
;;;1417   
;;;1418   BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
000000  e92d41f3          PUSH     {r0,r1,r4-r8,lr}
;;;1419   {
000004  b082              SUB      sp,sp,#8
000006  4605              MOV      r5,r0
;;;1420   BaseType_t xEntryTimeSet = pdFALSE;
000008  2700              MOVS     r7,#0
;;;1421   TimeOut_t xTimeOut;
;;;1422   Queue_t * const pxQueue = xQueue;
00000a  462c              MOV      r4,r5
;;;1423   
;;;1424   #if( configUSE_MUTEXES == 1 )
;;;1425   	BaseType_t xInheritanceOccurred = pdFALSE;
00000c  46b8              MOV      r8,r7
;;;1426   #endif
;;;1427   
;;;1428   	/* Check the queue pointer is not NULL. */
;;;1429   	configASSERT( ( pxQueue ) );
;;;1430   
;;;1431   	/* Check this really is a semaphore, in which case the item size will be
;;;1432   	0. */
;;;1433   	configASSERT( pxQueue->uxItemSize == 0 );
;;;1434   
;;;1435   	/* Cannot block if the scheduler is suspended. */
;;;1436   	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
;;;1437   	{
;;;1438   		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
;;;1439   	}
;;;1440   	#endif
;;;1441   
;;;1442   
;;;1443   	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
;;;1444   	statements within the function itself.  This is done in the interest
;;;1445   	of execution time efficiency. */
;;;1446   	for( ;; )
00000e  bf00              NOP      
                  |L25.16|
;;;1447   	{
;;;1448   		taskENTER_CRITICAL();
000010  f7fffffe          BL       vPortEnterCritical
;;;1449   		{
;;;1450   			/* Semaphores are queues with an item size of 0, and where the
;;;1451   			number of messages in the queue is the semaphore's count value. */
;;;1452   			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
000014  6ba6              LDR      r6,[r4,#0x38]
;;;1453   
;;;1454   			/* Is there data in the queue now?  To be running the calling task
;;;1455   			must be the highest priority task wanting to access the queue. */
;;;1456   			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
000016  b1fe              CBZ      r6,|L25.88|
;;;1457   			{
;;;1458   				traceQUEUE_RECEIVE( pxQueue );
;;;1459   
;;;1460   				/* Semaphores are queues with a data size of zero and where the
;;;1461   				messages waiting is the semaphore's count.  Reduce the count. */
;;;1462   				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
000018  1e70              SUBS     r0,r6,#1
00001a  63a0              STR      r0,[r4,#0x38]
;;;1463   
;;;1464   				#if ( configUSE_MUTEXES == 1 )
;;;1465   				{
;;;1466   					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
00001c  6820              LDR      r0,[r4,#0]
00001e  b910              CBNZ     r0,|L25.38|
;;;1467   					{
;;;1468   						/* Record the information required to implement
;;;1469   						priority inheritance should it become necessary. */
;;;1470   						pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
000020  f7fffffe          BL       pvTaskIncrementMutexHeldCount
000024  60a0              STR      r0,[r4,#8]
                  |L25.38|
;;;1471   					}
;;;1472   					else
;;;1473   					{
;;;1474   						mtCOVERAGE_TEST_MARKER();
;;;1475   					}
;;;1476   				}
;;;1477   				#endif /* configUSE_MUTEXES */
;;;1478   
;;;1479   				/* Check to see if other tasks are blocked waiting to give the
;;;1480   				semaphore, and if so, unblock the highest priority such task. */
;;;1481   				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
000026  6920              LDR      r0,[r4,#0x10]
000028  b908              CBNZ     r0,|L25.46|
00002a  2001              MOVS     r0,#1
00002c  e000              B        |L25.48|
                  |L25.46|
00002e  2000              MOVS     r0,#0
                  |L25.48|
000030  b960              CBNZ     r0,|L25.76|
;;;1482   				{
;;;1483   					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
000032  f1040010          ADD      r0,r4,#0x10
000036  f7fffffe          BL       xTaskRemoveFromEventList
00003a  b138              CBZ      r0,|L25.76|
;;;1484   					{
;;;1485   						queueYIELD_IF_USING_PREEMPTION();
00003c  f04f5080          MOV      r0,#0x10000000
000040  493a              LDR      r1,|L25.300|
000042  6008              STR      r0,[r1,#0]
000044  f3bf8f4f          DSB      
000048  f3bf8f6f          ISB      
                  |L25.76|
;;;1486   					}
;;;1487   					else
;;;1488   					{
;;;1489   						mtCOVERAGE_TEST_MARKER();
;;;1490   					}
;;;1491   				}
;;;1492   				else
;;;1493   				{
;;;1494   					mtCOVERAGE_TEST_MARKER();
;;;1495   				}
;;;1496   
;;;1497   				taskEXIT_CRITICAL();
00004c  f7fffffe          BL       vPortExitCritical
;;;1498   				return pdPASS;
000050  2001              MOVS     r0,#1
                  |L25.82|
;;;1499   			}
;;;1500   			else
;;;1501   			{
;;;1502   				if( xTicksToWait == ( TickType_t ) 0 )
;;;1503   				{
;;;1504   					/* For inheritance to have occurred there must have been an
;;;1505   					initial timeout, and an adjusted timeout cannot become 0, as
;;;1506   					if it were 0 the function would have exited. */
;;;1507   					#if( configUSE_MUTEXES == 1 )
;;;1508   					{
;;;1509   						configASSERT( xInheritanceOccurred == pdFALSE );
;;;1510   					}
;;;1511   					#endif /* configUSE_MUTEXES */
;;;1512   
;;;1513   					/* The semaphore count was 0 and no block time is specified
;;;1514   					(or the block time has expired) so exit now. */
;;;1515   					taskEXIT_CRITICAL();
;;;1516   					traceQUEUE_RECEIVE_FAILED( pxQueue );
;;;1517   					return errQUEUE_EMPTY;
;;;1518   				}
;;;1519   				else if( xEntryTimeSet == pdFALSE )
;;;1520   				{
;;;1521   					/* The semaphore count was 0 and a block time was specified
;;;1522   					so configure the timeout structure ready to block. */
;;;1523   					vTaskInternalSetTimeOutState( &xTimeOut );
;;;1524   					xEntryTimeSet = pdTRUE;
;;;1525   				}
;;;1526   				else
;;;1527   				{
;;;1528   					/* Entry time was already set. */
;;;1529   					mtCOVERAGE_TEST_MARKER();
;;;1530   				}
;;;1531   			}
;;;1532   		}
;;;1533   		taskEXIT_CRITICAL();
;;;1534   
;;;1535   		/* Interrupts and other tasks can give to and take from the semaphore
;;;1536   		now the critical section has been exited. */
;;;1537   
;;;1538   		vTaskSuspendAll();
;;;1539   		prvLockQueue( pxQueue );
;;;1540   
;;;1541   		/* Update the timeout state to see if it has expired yet. */
;;;1542   		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
;;;1543   		{
;;;1544   			/* A block time is specified and not expired.  If the semaphore
;;;1545   			count is 0 then enter the Blocked state to wait for a semaphore to
;;;1546   			become available.  As semaphores are implemented with queues the
;;;1547   			queue being empty is equivalent to the semaphore count being 0. */
;;;1548   			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
;;;1549   			{
;;;1550   				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
;;;1551   
;;;1552   				#if ( configUSE_MUTEXES == 1 )
;;;1553   				{
;;;1554   					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
;;;1555   					{
;;;1556   						taskENTER_CRITICAL();
;;;1557   						{
;;;1558   							xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
;;;1559   						}
;;;1560   						taskEXIT_CRITICAL();
;;;1561   					}
;;;1562   					else
;;;1563   					{
;;;1564   						mtCOVERAGE_TEST_MARKER();
;;;1565   					}
;;;1566   				}
;;;1567   				#endif
;;;1568   
;;;1569   				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
;;;1570   				prvUnlockQueue( pxQueue );
;;;1571   				if( xTaskResumeAll() == pdFALSE )
;;;1572   				{
;;;1573   					portYIELD_WITHIN_API();
;;;1574   				}
;;;1575   				else
;;;1576   				{
;;;1577   					mtCOVERAGE_TEST_MARKER();
;;;1578   				}
;;;1579   			}
;;;1580   			else
;;;1581   			{
;;;1582   				/* There was no timeout and the semaphore count was not 0, so
;;;1583   				attempt to take the semaphore again. */
;;;1584   				prvUnlockQueue( pxQueue );
;;;1585   				( void ) xTaskResumeAll();
;;;1586   			}
;;;1587   		}
;;;1588   		else
;;;1589   		{
;;;1590   			/* Timed out. */
;;;1591   			prvUnlockQueue( pxQueue );
;;;1592   			( void ) xTaskResumeAll();
;;;1593   
;;;1594   			/* If the semaphore count is 0 exit now as the timeout has
;;;1595   			expired.  Otherwise return to attempt to take the semaphore that is
;;;1596   			known to be available.  As semaphores are implemented by queues the
;;;1597   			queue being empty is equivalent to the semaphore count being 0. */
;;;1598   			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
;;;1599   			{
;;;1600   				#if ( configUSE_MUTEXES == 1 )
;;;1601   				{
;;;1602   					/* xInheritanceOccurred could only have be set if
;;;1603   					pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
;;;1604   					test the mutex type again to check it is actually a mutex. */
;;;1605   					if( xInheritanceOccurred != pdFALSE )
;;;1606   					{
;;;1607   						taskENTER_CRITICAL();
;;;1608   						{
;;;1609   							UBaseType_t uxHighestWaitingPriority;
;;;1610   
;;;1611   							/* This task blocking on the mutex caused another
;;;1612   							task to inherit this task's priority.  Now this task
;;;1613   							has timed out the priority should be disinherited
;;;1614   							again, but only as low as the next highest priority
;;;1615   							task that is waiting for the same mutex. */
;;;1616   							uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
;;;1617   							vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
;;;1618   						}
;;;1619   						taskEXIT_CRITICAL();
;;;1620   					}
;;;1621   				}
;;;1622   				#endif /* configUSE_MUTEXES */
;;;1623   
;;;1624   				traceQUEUE_RECEIVE_FAILED( pxQueue );
;;;1625   				return errQUEUE_EMPTY;
;;;1626   			}
;;;1627   			else
;;;1628   			{
;;;1629   				mtCOVERAGE_TEST_MARKER();
;;;1630   			}
;;;1631   		}
;;;1632   	} /*lint -restore */
;;;1633   }
000052  b004              ADD      sp,sp,#0x10
000054  e8bd81f0          POP      {r4-r8,pc}
                  |L25.88|
000058  9803              LDR      r0,[sp,#0xc]          ;1502
00005a  b918              CBNZ     r0,|L25.100|
00005c  f7fffffe          BL       vPortExitCritical
000060  2000              MOVS     r0,#0                 ;1517
000062  e7f6              B        |L25.82|
                  |L25.100|
000064  b91f              CBNZ     r7,|L25.110|
000066  4668              MOV      r0,sp                 ;1523
000068  f7fffffe          BL       vTaskInternalSetTimeOutState
00006c  2701              MOVS     r7,#1                 ;1524
                  |L25.110|
00006e  f7fffffe          BL       vPortExitCritical
000072  f7fffffe          BL       vTaskSuspendAll
000076  f7fffffe          BL       vPortEnterCritical
00007a  f9940044          LDRSB    r0,[r4,#0x44]         ;1539
00007e  1c40              ADDS     r0,r0,#1              ;1539
000080  b910              CBNZ     r0,|L25.136|
000082  2000              MOVS     r0,#0                 ;1539
000084  f8840044          STRB     r0,[r4,#0x44]         ;1539
                  |L25.136|
000088  f9940045          LDRSB    r0,[r4,#0x45]         ;1539
00008c  1c40              ADDS     r0,r0,#1              ;1539
00008e  b910              CBNZ     r0,|L25.150|
000090  2000              MOVS     r0,#0                 ;1539
000092  f8840045          STRB     r0,[r4,#0x45]         ;1539
                  |L25.150|
000096  f7fffffe          BL       vPortExitCritical
00009a  a903              ADD      r1,sp,#0xc            ;1542
00009c  4668              MOV      r0,sp                 ;1542
00009e  f7fffffe          BL       xTaskCheckForTimeOut
0000a2  bb40              CBNZ     r0,|L25.246|
0000a4  4620              MOV      r0,r4                 ;1548
0000a6  f7fffffe          BL       prvIsQueueEmpty
0000aa  b1f0              CBZ      r0,|L25.234|
0000ac  6820              LDR      r0,[r4,#0]            ;1554
0000ae  b938              CBNZ     r0,|L25.192|
0000b0  f7fffffe          BL       vPortEnterCritical
0000b4  68a0              LDR      r0,[r4,#8]            ;1558
0000b6  f7fffffe          BL       xTaskPriorityInherit
0000ba  4680              MOV      r8,r0                 ;1558
0000bc  f7fffffe          BL       vPortExitCritical
                  |L25.192|
0000c0  f1040024          ADD      r0,r4,#0x24           ;1569
0000c4  9903              LDR      r1,[sp,#0xc]          ;1569
0000c6  f7fffffe          BL       vTaskPlaceOnEventList
0000ca  4620              MOV      r0,r4                 ;1570
0000cc  f7fffffe          BL       prvUnlockQueue
0000d0  f7fffffe          BL       xTaskResumeAll
0000d4  2800              CMP      r0,#0                 ;1571
0000d6  d19b              BNE      |L25.16|
0000d8  f04f5080          MOV      r0,#0x10000000        ;1573
0000dc  4913              LDR      r1,|L25.300|
0000de  6008              STR      r0,[r1,#0]            ;1573
0000e0  f3bf8f4f          DSB                            ;1573
0000e4  f3bf8f6f          ISB                            ;1573
0000e8  e792              B        |L25.16|
                  |L25.234|
0000ea  4620              MOV      r0,r4                 ;1584
0000ec  f7fffffe          BL       prvUnlockQueue
0000f0  f7fffffe          BL       xTaskResumeAll
0000f4  e78c              B        |L25.16|
                  |L25.246|
0000f6  4620              MOV      r0,r4                 ;1591
0000f8  f7fffffe          BL       prvUnlockQueue
0000fc  f7fffffe          BL       xTaskResumeAll
000100  4620              MOV      r0,r4                 ;1598
000102  f7fffffe          BL       prvIsQueueEmpty
000106  2800              CMP      r0,#0                 ;1598
000108  d082              BEQ      |L25.16|
00010a  f1b80f00          CMP      r8,#0                 ;1605
00010e  d00b              BEQ      |L25.296|
000110  f7fffffe          BL       vPortEnterCritical
000114  4620              MOV      r0,r4                 ;1616
000116  f7fffffe          BL       prvGetDisinheritPriorityAfterTimeout
00011a  4606              MOV      r6,r0                 ;1616
00011c  4631              MOV      r1,r6                 ;1617
00011e  68a0              LDR      r0,[r4,#8]            ;1617
000120  f7fffffe          BL       vTaskPriorityDisinheritAfterTimeout
000124  f7fffffe          BL       vPortExitCritical
                  |L25.296|
000128  2000              MOVS     r0,#0                 ;1625
00012a  e792              B        |L25.82|
;;;1634   /*-----------------------------------------------------------*/
                          ENDP

                  |L25.300|
                          DCD      0xe000ed04
