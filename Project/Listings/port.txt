; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\port.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\port.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\User -I..\STM32F10x_StdPeriph_Libraries -I..\STM32F10x_StdPeriph_Libraries\STM32F10x_StdPeriph_Driver\src -I..\STM32F10x_StdPeriph_Libraries\STM32F10x_StdPeriph_Driver\inc -I..\STM32F10x_StdPeriph_Libraries\CMSIS\CM3\CoreSupport -I..\STM32F10x_StdPeriph_Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\STM32F10x_StdPeriph_Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\startup\arm -I..\FreeRTOS\Source -I..\FreeRTOS\Source\include -I..\FreeRTOS\Source\portable\RVDS\ARM_CM3 -I..\FreeRTOS\Source\portable\MemMang -I..\FreeRTOS -I..\User\Bsp -I..\SEGGER_RTT\RTT -I.\RTE\_Demo -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.0.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=523 -DSTM32F10X_MD -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER --omf_browse=.\objects\port.crf ..\FreeRTOS\Source\portable\RVDS\ARM_CM3\port.c]
                          THUMB

                          AREA ||i.prvTaskExitError||, CODE, READONLY, ALIGN=1

                  prvTaskExitError PROC
;;;193    
;;;194    static void prvTaskExitError( void )
000000  bf00              NOP      
000002  20bf              MOVS     r0,#0xbf
000004  f3808811          MSR      BASEPRI,r0
000008  f3bf8f4f          DSB      
00000c  f3bf8f6f          ISB      
000010  bf00              NOP      
;;;195    {
;;;196    	/* A function that implements a task must not exit or attempt to return to
;;;197    	its caller as there is nothing to return to.  If a task wants to exit it
;;;198    	should instead call vTaskDelete( NULL ).
;;;199    
;;;200    	Artificially force an assert() to be triggered if configASSERT() is
;;;201    	defined, then stop here so application writers can catch the error. */
;;;202    	configASSERT( uxCriticalNesting == ~0UL );
;;;203    	portDISABLE_INTERRUPTS();
;;;204    	for( ;; );
000012  bf00              NOP      
                  |L1.20|
000014  e7fe              B        |L1.20|
;;;205    }
;;;206    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.pxPortInitialiseStack||, CODE, READONLY, ALIGN=2

                  pxPortInitialiseStack PROC
;;;174     */
;;;175    StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
000000  1f00              SUBS     r0,r0,#4
;;;176    {
;;;177    	/* Simulate the stack frame as it would be created by a context switch
;;;178    	interrupt. */
;;;179    	pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
;;;180    	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
000002  f04f7380          MOV      r3,#0x1000000
000006  6003              STR      r3,[r0,#0]
;;;181    	pxTopOfStack--;
000008  1f00              SUBS     r0,r0,#4
;;;182    	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
00000a  f0210301          BIC      r3,r1,#1
00000e  6003              STR      r3,[r0,#0]
;;;183    	pxTopOfStack--;
000010  1f00              SUBS     r0,r0,#4
;;;184    	*pxTopOfStack = ( StackType_t ) prvTaskExitError;	/* LR */
000012  4b03              LDR      r3,|L2.32|
000014  6003              STR      r3,[r0,#0]
;;;185    
;;;186    	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
000016  3814              SUBS     r0,r0,#0x14
;;;187    	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
000018  6002              STR      r2,[r0,#0]
;;;188    	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */
00001a  3820              SUBS     r0,r0,#0x20
;;;189    
;;;190    	return pxTopOfStack;
;;;191    }
00001c  4770              BX       lr
;;;192    /*-----------------------------------------------------------*/
                          ENDP

00001e  0000              DCW      0x0000
                  |L2.32|
                          DCD      prvTaskExitError

                          AREA ||i.vPortEndScheduler||, CODE, READONLY, ALIGN=1

                  vPortEndScheduler PROC
;;;337    
;;;338    void vPortEndScheduler( void )
000000  4770              BX       lr
;;;339    {
;;;340    	/* Not implemented in ports where there is nothing to return to.
;;;341    	Artificially force an assert. */
;;;342    	configASSERT( uxCriticalNesting == 1000UL );
;;;343    }
;;;344    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.vPortEnterCritical||, CODE, READONLY, ALIGN=2

                  vPortEnterCritical PROC
;;;345    
;;;346    void vPortEnterCritical( void )
000000  bf00              NOP      
000002  20bf              MOVS     r0,#0xbf
000004  f3808811          MSR      BASEPRI,r0
000008  f3bf8f4f          DSB      
00000c  f3bf8f6f          ISB      
000010  bf00              NOP      
;;;347    {
;;;348    	portDISABLE_INTERRUPTS();
;;;349    	uxCriticalNesting++;
000012  4803              LDR      r0,|L4.32|
000014  6800              LDR      r0,[r0,#0]  ; uxCriticalNesting
000016  1c40              ADDS     r0,r0,#1
000018  4901              LDR      r1,|L4.32|
00001a  6008              STR      r0,[r1,#0]  ; uxCriticalNesting
;;;350    
;;;351    	/* This is not the interrupt safe version of the enter critical function so
;;;352    	assert() if it is being called from an interrupt context.  Only API
;;;353    	functions that end in "FromISR" can be used in an interrupt.  Only assert if
;;;354    	the critical nesting count is 1 to protect against recursive calls if the
;;;355    	assert function also uses a critical section. */
;;;356    	if( uxCriticalNesting == 1 )
;;;357    	{
;;;358    		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
;;;359    	}
;;;360    }
00001c  4770              BX       lr
;;;361    /*-----------------------------------------------------------*/
                          ENDP

00001e  0000              DCW      0x0000
                  |L4.32|
                          DCD      uxCriticalNesting

                          AREA ||i.vPortExitCritical||, CODE, READONLY, ALIGN=2

                  vPortExitCritical PROC
;;;362    
;;;363    void vPortExitCritical( void )
000000  4806              LDR      r0,|L5.28|
;;;364    {
;;;365    	configASSERT( uxCriticalNesting );
;;;366    	uxCriticalNesting--;
000002  6800              LDR      r0,[r0,#0]  ; uxCriticalNesting
000004  1e40              SUBS     r0,r0,#1
000006  4905              LDR      r1,|L5.28|
000008  6008              STR      r0,[r1,#0]  ; uxCriticalNesting
;;;367    	if( uxCriticalNesting == 0 )
00000a  4608              MOV      r0,r1
00000c  6800              LDR      r0,[r0,#0]  ; uxCriticalNesting
00000e  b920              CBNZ     r0,|L5.26|
;;;368    	{
;;;369    		portENABLE_INTERRUPTS();
000010  2000              MOVS     r0,#0
000012  f3808811          MSR      BASEPRI,r0
000016  bf00              NOP      
000018  bf00              NOP      
                  |L5.26|
;;;370    	}
;;;371    }
00001a  4770              BX       lr
;;;372    /*-----------------------------------------------------------*/
                          ENDP

                  |L5.28|
                          DCD      uxCriticalNesting

                          AREA ||i.vPortSetupTimerInterrupt||, CODE, READONLY, ALIGN=2

                  vPortSetupTimerInterrupt PROC
;;;605    
;;;606    	__weak void vPortSetupTimerInterrupt( void )
000000  2000              MOVS     r0,#0
;;;607    	{
;;;608    		/* Calculate the constants required to configure the tick interrupt. */
;;;609    		#if( configUSE_TICKLESS_IDLE == 1 )
;;;610    		{
;;;611    			ulTimerCountsForOneTick = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ );
;;;612    			xMaximumPossibleSuppressedTicks = portMAX_24_BIT_NUMBER / ulTimerCountsForOneTick;
;;;613    			ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
;;;614    		}
;;;615    		#endif /* configUSE_TICKLESS_IDLE */
;;;616    
;;;617    		/* Stop and clear the SysTick. */
;;;618    		portNVIC_SYSTICK_CTRL_REG = 0UL;
000002  f04f21e0          MOV      r1,#0xe000e000
000006  6108              STR      r0,[r1,#0x10]
;;;619    		portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
000008  6188              STR      r0,[r1,#0x18]
;;;620    
;;;621    		/* Configure SysTick to interrupt at the requested rate. */
;;;622    		portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
00000a  4802              LDR      r0,|L6.20|
00000c  6148              STR      r0,[r1,#0x14]
;;;623    		portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
00000e  2007              MOVS     r0,#7
000010  6108              STR      r0,[r1,#0x10]
;;;624    	}
000012  4770              BX       lr
;;;625    
                          ENDP

                  |L6.20|
                          DCD      0x0001193f

                          AREA ||i.xPortStartScheduler||, CODE, READONLY, ALIGN=2

                  xPortStartScheduler PROC
;;;250     */
;;;251    BaseType_t xPortStartScheduler( void )
000000  b510              PUSH     {r4,lr}
;;;252    {
;;;253    	#if( configASSERT_DEFINED == 1 )
;;;254    	{
;;;255    		volatile uint32_t ulOriginalPriority;
;;;256    		volatile uint8_t * const pucFirstUserPriorityRegister = ( uint8_t * ) ( portNVIC_IP_REGISTERS_OFFSET_16 + portFIRST_USER_INTERRUPT_NUMBER );
;;;257    		volatile uint8_t ucMaxPriorityValue;
;;;258    
;;;259    		/* Determine the maximum priority from which ISR safe FreeRTOS API
;;;260    		functions can be called.  ISR safe functions are those that end in
;;;261    		"FromISR".  FreeRTOS maintains separate thread and ISR API functions to
;;;262    		ensure interrupt entry is as fast and simple as possible.
;;;263    
;;;264    		Save the interrupt priority value that is about to be clobbered. */
;;;265    		ulOriginalPriority = *pucFirstUserPriorityRegister;
;;;266    
;;;267    		/* Determine the number of priority bits available.  First write to all
;;;268    		possible bits. */
;;;269    		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
;;;270    
;;;271    		/* Read the value back to see how many bits stuck. */
;;;272    		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
;;;273    
;;;274    		/* The kernel interrupt priority should be set to the lowest
;;;275    		priority. */
;;;276    		configASSERT( ucMaxPriorityValue == ( configKERNEL_INTERRUPT_PRIORITY & ucMaxPriorityValue ) );
;;;277    
;;;278    		/* Use the same mask on the maximum system call priority. */
;;;279    		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
;;;280    
;;;281    		/* Calculate the maximum acceptable priority group value for the number
;;;282    		of bits read back. */
;;;283    		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
;;;284    		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
;;;285    		{
;;;286    			ulMaxPRIGROUPValue--;
;;;287    			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
;;;288    		}
;;;289    
;;;290    		#ifdef __NVIC_PRIO_BITS
;;;291    		{
;;;292    			/* Check the CMSIS configuration that defines the number of
;;;293    			priority bits matches the number of priority bits actually queried
;;;294    			from the hardware. */
;;;295    			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == __NVIC_PRIO_BITS );
;;;296    		}
;;;297    		#endif
;;;298    
;;;299    		#ifdef configPRIO_BITS
;;;300    		{
;;;301    			/* Check the FreeRTOS configuration that defines the number of
;;;302    			priority bits matches the number of priority bits actually queried
;;;303    			from the hardware. */
;;;304    			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == configPRIO_BITS );
;;;305    		}
;;;306    		#endif
;;;307    
;;;308    		/* Shift the priority group value back to its position within the AIRCR
;;;309    		register. */
;;;310    		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
;;;311    		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
;;;312    
;;;313    		/* Restore the clobbered interrupt priority register to its original
;;;314    		value. */
;;;315    		*pucFirstUserPriorityRegister = ulOriginalPriority;
;;;316    	}
;;;317    	#endif /* conifgASSERT_DEFINED */
;;;318    
;;;319    	/* Make PendSV and SysTick the lowest priority interrupts. */
;;;320    	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
000002  480a              LDR      r0,|L7.44|
000004  6800              LDR      r0,[r0,#0]
000006  f440007f          ORR      r0,r0,#0xff0000
00000a  4908              LDR      r1,|L7.44|
00000c  6008              STR      r0,[r1,#0]
;;;321    	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
00000e  4608              MOV      r0,r1
000010  6800              LDR      r0,[r0,#0]
000012  f040407f          ORR      r0,r0,#0xff000000
000016  6008              STR      r0,[r1,#0]
;;;322    
;;;323    	/* Start the timer that generates the tick ISR.  Interrupts are disabled
;;;324    	here already. */
;;;325    	vPortSetupTimerInterrupt();
000018  f7fffffe          BL       vPortSetupTimerInterrupt
;;;326    
;;;327    	/* Initialise the critical nesting count ready for the first task. */
;;;328    	uxCriticalNesting = 0;
00001c  2000              MOVS     r0,#0
00001e  4904              LDR      r1,|L7.48|
000020  6008              STR      r0,[r1,#0]  ; uxCriticalNesting
;;;329    
;;;330    	/* Start the first task. */
;;;331    	prvStartFirstTask();
000022  f7fffffe          BL       __asm___6_port_c_39a90d8d__prvStartFirstTask
;;;332    
;;;333    	/* Should not get here! */
;;;334    	return 0;
000026  2000              MOVS     r0,#0
;;;335    }
000028  bd10              POP      {r4,pc}
;;;336    /*-----------------------------------------------------------*/
                          ENDP

00002a  0000              DCW      0x0000
                  |L7.44|
                          DCD      0xe000ed20
                  |L7.48|
                          DCD      uxCriticalNesting

                          AREA ||i.xPortSysTickHandler||, CODE, READONLY, ALIGN=2

                  xPortSysTickHandler PROC
;;;410    
;;;411    void xPortSysTickHandler( void )
000000  b510              PUSH     {r4,lr}
;;;412    {
;;;413    	/* The SysTick runs at the lowest interrupt priority, so when this interrupt
;;;414    	executes all interrupts must be unmasked.  There is therefore no need to
;;;415    	save and then restore the interrupt mask value as its value is already
;;;416    	known - therefore the slightly faster vPortRaiseBASEPRI() function is used
;;;417    	in place of portSET_INTERRUPT_MASK_FROM_ISR(). */
;;;418    	vPortRaiseBASEPRI();
000002  bf00              NOP      
000004  20bf              MOVS     r0,#0xbf
000006  f3808811          MSR      BASEPRI,r0
00000a  f3bf8f4f          DSB      
00000e  f3bf8f6f          ISB      
000012  bf00              NOP      
;;;419    	{
;;;420    		/* Increment the RTOS tick. */
;;;421    		if( xTaskIncrementTick() != pdFALSE )
000014  f7fffffe          BL       xTaskIncrementTick
000018  b118              CBZ      r0,|L8.34|
;;;422    		{
;;;423    			/* A context switch is required.  Context switching is performed in
;;;424    			the PendSV interrupt.  Pend the PendSV interrupt. */
;;;425    			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
00001a  f04f5080          MOV      r0,#0x10000000
00001e  4904              LDR      r1,|L8.48|
000020  6008              STR      r0,[r1,#0]
                  |L8.34|
;;;426    		}
;;;427    	}
;;;428    	vPortClearBASEPRIFromISR();
000022  bf00              NOP      
000024  2000              MOVS     r0,#0
000026  f3808811          MSR      BASEPRI,r0
00002a  bf00              NOP      
;;;429    }
00002c  bd10              POP      {r4,pc}
;;;430    /*-----------------------------------------------------------*/
                          ENDP

00002e  0000              DCW      0x0000
                  |L8.48|
                          DCD      0xe000ed04

                          AREA ||.data||, DATA, ALIGN=2

                  uxCriticalNesting
                          DCD      0xaaaaaaaa

;*** Start embedded assembler ***

#line 1 "..\\FreeRTOS\\Source\\portable\\RVDS\\ARM_CM3\\port.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |vPortSVCHandler|
#line 208
|vPortSVCHandler| PROC
#line 209

 PRESERVE8

 ldr r3, =pxCurrentTCB  
 ldr r1, [r3]  
 ldr r0, [r1]  
 ldmia r0!, {r4-r11}  
 msr psp, r0  
 isb
 mov r0, #0
 msr basepri, r0
 orr r14, #0xd
 bx r14
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___6_port_c_39a90d8d__prvStartFirstTask|
#line 225
|__asm___6_port_c_39a90d8d__prvStartFirstTask| PROC
#line 226

 PRESERVE8

 
 ldr r0, =0xE000ED08
 ldr r0, [r0]
 ldr r0, [r0]

 
 msr msp, r0
 
 cpsie i
 cpsie f
 dsb
 isb
 
 svc 0
 nop
 nop
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |xPortPendSVHandler|
#line 374
|xPortPendSVHandler| PROC
#line 375

 extern uxCriticalNesting
 extern pxCurrentTCB
 extern vTaskSwitchContext

 PRESERVE8

 mrs r0, psp
 isb

 ldr r3, =pxCurrentTCB  
 ldr r2, [r3]

 stmdb r0!, {r4-r11}  
 str r0, [r2]  

 stmdb sp!, {r3, r14}
 mov r0, #191
 msr basepri, r0
 dsb
 isb
 bl vTaskSwitchContext
 mov r0, #0
 msr basepri, r0
 ldmia sp!, {r3, r14}

 ldr r1, [r3]
 ldr r0, [r1]  
 ldmia r0!, {r4-r11}  
 msr psp, r0
 isb
 bx r14
 nop
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |vPortGetIPSR|
#line 629
|vPortGetIPSR| PROC
#line 630

 PRESERVE8

 mrs r0, ipsr
 bx r14
	ENDP

;*** End   embedded assembler ***
